"use strict";
(() => {
  var __accessCheck = (obj, member, msg) => {
    if (!member.has(obj))
      throw TypeError("Cannot " + msg);
  };
  var __privateGet = (obj, member, getter) => {
    __accessCheck(obj, member, "read from private field");
    return getter ? getter.call(obj) : member.get(obj);
  };
  var __privateAdd = (obj, member, value) => {
    if (member.has(obj))
      throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  };
  var __privateSet = (obj, member, value, setter) => {
    __accessCheck(obj, member, "write to private field");
    setter ? setter.call(obj, value) : member.set(obj, value);
    return value;
  };

  // src/directives/registry.ts
  var directiveRegistry = {};

  // src/core/$.ts
  var $ = /* @__PURE__ */ new WeakMap();

  // src/utils/get-parent.ts
  var getParent = (node) => {
    return node.parentNode instanceof ShadowRoot ? node.parentNode.host : node.parentNode;
  };

  // src/tracker/utils/define-node-context-metadata.ts
  function defineNodeContextMetadata(node) {
    if ($.has(node) && $.get(node)?.$context) {
      return;
    }
    let ctx = {};
    const dt = $.get(node) || {};
    dt.updateContext = (newCtx = null) => {
      const oldCtx = ctx;
      if (newCtx && typeof newCtx === "object" && Object.keys(newCtx).length) {
        ctx = { ...ctx, ...newCtx };
      }
      return { oldCtx, newCtx: ctx };
    };
    Object.defineProperty(dt, "$context", {
      get() {
        return { ...$.get(getParent(node))?.$context, ...ctx };
      }
    });
    $.set(node, dt);
  }

  // src/core/Directive.ts
  var Directive = class {
    constructor(component) {
      $.set(this, { component });
    }
    static register(name = "") {
      name = (name || this.name).toLowerCase();
      if (!directiveRegistry.hasOwnProperty(name)) {
        directiveRegistry[name] = this;
      }
    }
    parseValue(value, prop) {
      return value;
    }
    render(val, { element }) {
      return element;
    }
    setRef(name, node) {
      const currRef = $.get(this).component.$refs[name];
      if (currRef === void 0) {
        $.get(this).component.$refs[name] = node;
      } else if (Array.isArray(currRef)) {
        !currRef.includes(node) && currRef.push(node);
      } else if (currRef !== node) {
        $.get(this).component.$refs[name] = [currRef, node];
      }
    }
    getContext(node) {
      return $.get(node).$context ?? null;
    }
    updateContext(node, newCtx) {
      defineNodeContextMetadata(node);
      $.get(node)?.updateContext(newCtx);
    }
  };

  // src/directives/If.directive.ts
  var If = class extends Directive {
    render(condition, { element, anchorNode }) {
      return condition ? element : anchorNode || new Comment(` if: ${condition} `);
    }
  };

  // src/directives/Ref.directive.ts
  var Ref = class extends Directive {
    parseValue(value) {
      return `"${value}"`;
    }
    render(name, { element }) {
      if (/^[a-z$_][a-z0-9$_]*$/i.test(name)) {
        this.setRef(name, element);
        return element;
      }
      throw new Error(`Invalid "ref" property name "${name}"`);
    }
  };

  // src/utils/turn-kebab-to-camel-casing.ts
  function turnKebabToCamelCasing(name) {
    return name.split(/-+/).map((part, i) => i === 0 && part.length > 1 ? part : part[0].toUpperCase() + part.slice(1)).join("") ?? name;
  }

  // src/utils/turn-camel-to-kebab-casing.ts
  function turnCamelToKebabCasing(name) {
    return name.match(/(?:[A-Z]+(?=[A-Z][a-z])|[A-Z]+|[a-zA-Z])[a-z]*/g)?.map((p) => p.toLowerCase()).join("-") ?? name;
  }

  // src/core/boolean-attributes.json
  var boolean_attributes_default = {
    allowfullscreen: {
      value: false,
      name: "allowFullscreen"
    },
    allowpaymentrequest: {
      value: false,
      name: "allowPaymentRequest"
    },
    async: {
      value: false,
      name: "async"
    },
    autofocus: {
      value: false,
      name: "autofocus"
    },
    autoplay: {
      value: false,
      name: "autoplay"
    },
    checked: {
      value: false,
      name: "checked"
    },
    controls: {
      value: false,
      name: "controls"
    },
    default: {
      value: false,
      name: "default"
    },
    defer: {
      value: false,
      name: "defer"
    },
    disabled: {
      value: false,
      name: "disabled"
    },
    formnovlidate: {
      value: false,
      name: "formNoValidate"
    },
    hidden: {
      value: false,
      name: "hidden"
    },
    ismap: {
      value: false,
      name: "isMap"
    },
    itemscope: {
      value: false,
      name: "itemScope"
    },
    loop: {
      value: false,
      name: "loop"
    },
    multiple: {
      value: false,
      name: "multiple"
    },
    muted: {
      value: false,
      name: "muted"
    },
    nomodule: {
      value: false,
      name: "noModule"
    },
    novalidate: {
      value: false,
      name: "novalidate"
    },
    open: {
      value: false,
      name: "open"
    },
    playsinline: {
      value: false,
      name: "playsInline"
    },
    readonly: {
      value: false,
      name: "readonly"
    },
    required: {
      value: false,
      name: "required"
    },
    reversed: {
      value: false,
      name: "reversed"
    },
    selected: {
      value: false,
      name: "selected"
    },
    truspeed: {
      value: false,
      name: "truSpeed"
    }
  };

  // src/directives/Attr.directive.ts
  var Attr = class extends Directive {
    parseValue(value, prop) {
      let [attrName, property = null] = (prop ?? "").split(".");
      const commaIdx = value.lastIndexOf(",");
      return `["${attrName}", "${property || ""}", ${commaIdx >= 0 ? value.slice(commaIdx + 1).trim() : value}, "${commaIdx >= 0 ? value.slice(0, commaIdx).trim() : ""}"]`;
    }
    render([attrName, property, shouldAdd, val], { element }) {
      switch (attrName) {
        case "style":
          if (property) {
            property = turnKebabToCamelCasing(property);
            element.style[property] = shouldAdd ? val : "";
          } else {
            val.match(/([a-z][a-z-]+)(?=:):([^;]+)/g)?.forEach((style) => {
              let [name, styleValue] = style.split(":").map((s) => s.trim());
              if (shouldAdd) {
                element.style.setProperty(name, styleValue);
              } else {
                element.style.removeProperty(name);
              }
            });
          }
          break;
        case "class":
          if (property) {
            if (shouldAdd) {
              element.classList.add(property);
            } else {
              element.classList.remove(property);
            }
          } else {
            const classes = val.split(/\s+/g);
            if (shouldAdd) {
              classes.forEach((cls) => element.classList.add(cls));
            } else {
              classes.forEach((cls) => element.classList.remove(cls));
            }
          }
          break;
        case "data":
          if (property) {
            if (shouldAdd) {
              element.dataset[turnKebabToCamelCasing(property)] = val;
            } else {
              element.removeAttribute(`data-${turnCamelToKebabCasing(property)}`);
            }
          }
          break;
        default:
          if (attrName) {
            if (shouldAdd) {
              element.setAttribute(
                attrName,
                boolean_attributes_default.hasOwnProperty(attrName) ? "" : `${val || shouldAdd}`
              );
            } else {
              element.removeAttribute(attrName);
            }
          }
      }
      return element;
    }
  };

  // src/parser/self-closing-tags.json
  var self_closing_tags_default = {
    AREA: "AREA",
    META: "META",
    BASE: "BASE",
    BR: "BR",
    COL: "COL",
    EMBED: "EMBED",
    HR: "HR",
    IMG: "IMG",
    INPUT: "INPUT",
    LINK: "LINK",
    PARAM: "PARAM",
    SOURCE: "SOURCE",
    TRACK: "TRACK",
    WBR: "WBR",
    COMMAND: "COMMAND",
    KEYGEN: "KEYGEN",
    MENUITEM: "MENUITEM",
    DOCTYPE: "DOCTYPE",
    "!DOCTYPE": "!DOCTYPE"
  };

  // src/parser/parse.ts
  var NSURI = {
    HTML: "http://www.w3.org/1999/xhtml",
    SVG: "http://www.w3.org/2000/svg"
  };
  function parse(markup) {
    const tagCommentPattern = /<!--([^]*?)-->|<(\/|!)?([a-z][\w-.:]*)((?:\s*[a-z][\w-.:]*(?:\s*=\s*(?:"[^"]*"|'[^']*'))?)+\s*|\s*)(\/?)>/ig;
    const root = document.createDocumentFragment();
    const stack = [root];
    let match = null;
    let lastIndex = 0;
    let isNSTag = false;
    let URI = "";
    while ((match = tagCommentPattern.exec(markup)) !== null) {
      let [fullMatch, comment, closeOrBangSymbol, tagName, attributes, selfCloseSlash] = match;
      tagName = tagName?.toUpperCase();
      if (closeOrBangSymbol === "!") {
        continue;
      }
      const parentNode = stack[stack.length - 1] || null;
      if (lastIndex !== match.index) {
        const textNode = document.createTextNode(markup.slice(lastIndex, match.index));
        parentNode.appendChild(textNode);
      }
      lastIndex = tagCommentPattern.lastIndex;
      if (comment) {
        const commentNode = document.createComment(comment);
        parentNode.appendChild(commentNode);
        continue;
      }
      isNSTag = isNSTag || /SVG|HTML/i.test(tagName);
      if (/SVG|HTML/i.test(tagName)) {
        URI = NSURI[tagName.toUpperCase()];
      }
      if (selfCloseSlash || self_closing_tags_default[tagName]) {
        const node = isNSTag ? document.createElementNS(URI, tagName.toLowerCase()) : document.createElement(tagName);
        setAttributes(node, attributes);
        parentNode.appendChild(node);
      } else if (closeOrBangSymbol === "/") {
        isNSTag = /SVG|HTML/i.test(tagName) ? false : isNSTag;
        URI = /SVG|HTML/i.test(tagName) ? "" : URI;
        stack.pop();
      } else if (!closeOrBangSymbol) {
        const node = isNSTag ? document.createElementNS(URI, tagName.toLowerCase()) : document.createElement(tagName);
        setAttributes(node, attributes);
        parentNode.appendChild(node);
        stack.push(node);
      }
    }
    if (lastIndex < markup.length) {
      const textNode = document.createTextNode(markup.slice(lastIndex));
      root.appendChild(textNode);
    }
    return root;
  }
  function setAttributes(node, attributes) {
    const attrPattern = /([a-z][\w-.:]*)(?:\s*=\s*(?:"([^"]*)"|'([^']*)'|(\S+)))?/ig;
    let match = null;
    while (match = attrPattern.exec(attributes)) {
      let name = match[1];
      const value = match[2] || match[3] || match[4] || (new RegExp(`^${match[1]}\\s*=`).test(match[0]) ? "" : null);
      node.setAttribute(name, value ?? "");
    }
  }

  // src/directives/Repeat.directive.ts
  var Repeat = class extends Directive {
    parseValue(value) {
      const idx = value.lastIndexOf(";");
      let iPart = value;
      let kPart = "";
      if (idx > 0) {
        iPart = value.slice(0, idx);
        kPart = value.slice(idx + 1);
      }
      const [v, vAs = "$item"] = `${iPart} `.split(/\s+as\s+/g).map((s) => s.trim());
      const [k, kAs = "$key"] = `${kPart} `.split(/\s+as\s+/g).map((s) => s.trim());
      return `[${v}, "${vAs}", "${k === "$key" ? kAs : ""}"]`;
    }
    render([repeatData, vAs, kAs], { element, rawElementOuterHTML, anchorNode }) {
      anchorNode = anchorNode ?? [];
      const list = [];
      if (element.nodeType === 1) {
        let times;
        if (Number.isInteger(repeatData)) {
          times = repeatData;
        } else {
          repeatData = repeatData instanceof Set ? Object.entries(Array.from(repeatData)) : repeatData instanceof Map ? Array.from(repeatData.entries()) : repeatData[Symbol.iterator] ? Object.entries([...repeatData]) : Object.entries(repeatData);
          times = repeatData.length;
        }
        for (let index = 0; index < times; index++) {
          if (anchorNode[index]) {
            this.updateNodeContext(anchorNode[index], index, vAs, kAs, repeatData);
            list.push(anchorNode[index]);
            continue;
          }
          const el = parse(rawElementOuterHTML).children[0];
          this.updateNodeContext(el, index, vAs, kAs, repeatData);
          list.push(el);
        }
      }
      return list;
    }
    updateNodeContext(el, index, vAs, kAs, list = []) {
      const [key, value] = list[index] ?? [index, index + 1];
      this.updateContext(el, {
        [vAs || "$item"]: value,
        [kAs || "$key"]: key
      });
    }
  };

  // src/directives/Bind.directive.ts
  var Bind = class extends Directive {
    parseValue(value, prop) {
      return `["${(prop || "").trim()}", "${value}"]`;
    }
    render([prop, value], { element, anchorNode }) {
      if (prop) {
        element[prop] = value;
      } else {
        element.textContent = value;
      }
      return element;
    }
  };

  // src/directives/index.ts
  If.register();
  Ref.register();
  Attr.register();
  Repeat.register();
  Bind.register();
  var directives = /* @__PURE__ */ new Set([
    If.name.toLowerCase(),
    Ref.name.toLowerCase(),
    Attr.name.toLowerCase(),
    Repeat.name.toLowerCase(),
    Bind.name.toLowerCase()
  ]);

  // src/utils/is-primitive.ts
  var isPrimitive = (val) => {
    return /number|string|bigint|boolean|symbol/.test(typeof val);
  };

  // src/utils/proxify.ts
  var TypedArray = Object.getPrototypeOf(Uint8Array);
  function proxify(name, object, notify = () => {
  }, self = null) {
    self = self ?? object;
    if (!object || object.__isProxy || isPrimitive(object) || typeof object === "function" || ![Array, Map, Set, TypedArray].some((o) => object instanceof o) && (object.constructor && object.constructor.name !== "Object")) {
      return object;
    }
    return new Proxy(object, {
      get(obj, n) {
        if (n === "__isProxy") {
          return true;
        }
        if (n === "__raw") {
          return object;
        }
        let res = Reflect.get(obj, n);
        if (res) {
          if (typeof res === "object") {
            return proxify(name, res, notify, self);
          }
          if (typeof res === "function") {
            if (typeof n !== "symbol") {
              if (/forEach/.test(n)) {
                return (cb, thisArg) => {
                  obj[n]((v, k, l) => {
                    cb.call(thisArg ?? obj, proxify(name, v, notify, self), k, l);
                  }, thisArg ?? obj);
                };
              } else if (/values|entries|keys/.test(n)) {
                return () => ({
                  *[Symbol.iterator]() {
                    if (n === "entries") {
                      for (const [k, v] of obj[n]()) {
                        yield [proxify(name, k, notify, self), proxify(name, v, notify, self)];
                      }
                    } else {
                      for (const v of obj[n]()) {
                        yield proxify(name, v, notify, self);
                      }
                    }
                  }
                });
              }
              return (...args) => {
                const r = res.apply(obj, args);
                if (typeof r === "object" && (Array.isArray(obj) && /at|find/.test(n) || obj instanceof Map && /get/.test(n) || obj instanceof WeakMap && /get/.test(n))) {
                  return proxify(name, r, notify, self);
                }
                if (Array.isArray(obj) && /push|pop|splice|shift|unshift|reverse|sort|fill|copyWithin/.test(n) || obj instanceof Map && /set|delete|clear/.test(n) || obj instanceof Set && /add|delete|clear/.test(n) || obj instanceof WeakSet && /add|delete/.test(n) || obj instanceof WeakMap && /set|delete/.test(n)) {
                  notify(name, self);
                }
                return r;
              };
            } else {
              res = res.bind(obj);
            }
          }
        }
        return res;
      },
      set(obj, n, value) {
        const res = Reflect.set(obj, n, value);
        notify(name, self);
        return res;
      },
      deleteProperty(target, p) {
        const res = Reflect.deleteProperty(target, p);
        notify(name, self);
        return res;
      },
      defineProperty(target, p, attributes) {
        const res = Reflect.defineProperty(target, p, attributes);
        notify(name, self);
        return res;
      }
    });
  }

  // src/utils/json-parse.ts
  function jsonParse(value) {
    if (value && typeof value === "string") {
      try {
        value = JSON.parse(value.replace(/['`]/g, '"'));
      } catch (e) {
      }
    }
    return value;
  }

  // src/core/utils/set-component-properties-from-observed-attributes.ts
  function setComponentPropertiesFromObservedAttributes(comp, attrs, attrsMap = {}, cb) {
    const properties = [];
    attrs.forEach((attr) => {
      attr = attr.trim();
      if (!directives.has(attr) && !(attr.startsWith("data-") || attr === "class" || attr === "style")) {
        let prop = attrsMap[attr];
        let value = comp.getAttribute(attr) ?? comp[prop] ?? "";
        properties.push(prop);
        if (typeof value === "string") {
          value = proxify(prop, jsonParse(value), (name, val) => {
            cb(name, val, val);
          });
        }
        if (boolean_attributes_default.hasOwnProperty(prop)) {
          value = comp.hasAttribute(attr);
          prop = boolean_attributes_default[prop].name;
        }
        Object.defineProperty(comp, prop, {
          get() {
            return value;
          },
          set(newValue) {
            const oldValue = value;
            if (!isPrimitive(newValue)) {
              if (comp.hasAttribute(attr)) {
                $.get(comp).clearAttr = true;
                comp.removeAttribute(attr);
              }
              value = proxify(prop, newValue, () => {
                cb(prop, oldValue, newValue);
              });
              cb(prop, oldValue, value);
            } else if (oldValue !== newValue) {
              value = newValue;
              cb(prop, oldValue, value);
            }
          }
        });
      }
    });
    return properties;
  }

  // src/core/utils/setup-component-properties-for-auto-update.ts
  function setupComponentPropertiesForAutoUpdate(comp, onUpdate) {
    const properties = [];
    for (let prop of Object.getOwnPropertyNames(comp)) {
      if (typeof comp[prop] === "function") {
        continue;
      }
      if (!directives.has(prop) && !comp.$properties.includes(prop) && !comp.constructor.observedAttributes.includes(turnCamelToKebabCasing(prop))) {
        let value = comp[prop];
        properties.push(prop);
        value = proxify(prop, value, () => {
          onUpdate(prop, value, value);
        });
        Object.defineProperty(comp, prop, {
          get() {
            return value;
          },
          set(newValue) {
            const oldValue = value;
            if (typeof newValue !== "function") {
              if (!isPrimitive(newValue)) {
                value = proxify(prop, newValue, () => {
                  onUpdate(prop, oldValue, newValue);
                });
                onUpdate(prop, oldValue, value);
              } else if (oldValue !== newValue) {
                value = newValue;
                onUpdate(prop, oldValue, value);
              }
            }
          }
        });
      }
    }
    return properties;
  }

  // src/core/utils/replace-host.ts
  var replaceHost = (css2, tagName) => css2.replace(/:(host-context|host)(?:\s*\((.*?)\))?/gmi, (_, h, s) => {
    if (h === "host-context") {
      return `${(s || "").trim()} ${tagName}`;
    }
    return `${tagName}${(s || "").trim()}`;
  });

  // src/core/utils/get-style-string.ts
  function getStyleString(stylesheet, tagName, hasShadowRoot = true) {
    stylesheet = stylesheet.trim().replace(/\s{2,}/g, " ");
    if (!stylesheet) {
      return "";
    }
    const div = document.createElement("div");
    div.innerHTML = stylesheet;
    const styleTag = document.createElement("style");
    const links = [];
    const styles = [styleTag];
    Array.from(div.childNodes).forEach((child) => {
      if (child.nodeName === "LINK" && (child.getAttribute("rel") || "").trim() === "stylesheet") {
        links.push(child);
      } else if (child.nodeName === "STYLE") {
        styles.push(child);
      } else if (child.nodeName === "#text") {
        styleTag.appendChild(child);
      }
    });
    if (!hasShadowRoot) {
      links.forEach((link) => {
        link.classList.add(tagName);
      });
      for (let style of styles) {
        style.classList.add(tagName);
        style.textContent = replaceHost(style.innerHTML, tagName);
      }
    }
    return links.map((el) => el.outerHTML).join("") + styles.filter((el) => (el.textContent || "").trim()).map((el) => el.outerHTML).join("");
  }

  // src/utils/resolve-html-entities.ts
  function resolveHtmlEntities(html2) {
    const e = document.createElement("textarea");
    e.innerHTML = html2;
    return e.textContent || "";
  }

  // src/tracker/utils/evaluate-string-in-component-context.ts
  function evaluateStringInComponentContext(executable, component, nodeData = {}) {
    if (!executable.trim()) {
      return "";
    }
    const ctx = component.$context;
    const keys = Array.from(/* @__PURE__ */ new Set([
      ...Object.getOwnPropertyNames(nodeData),
      ...component.$properties,
      ...Object.getOwnPropertyNames(ctx)
    ]));
    const values = keys.map((key) => {
      return nodeData[key] ?? component[key] ?? ctx[key] ?? null;
    });
    return new Function(...keys, `"use strict";
 return ${executable};`).apply(component, values) ?? "";
  }

  // src/utils/json-stringify.ts
  function jsonStringify(value) {
    if (value && typeof value !== "string") {
      try {
        value = JSON.stringify(value);
      } catch (e) {
      }
    }
    return value;
  }

  // src/tracker/utils/resolve-executables.ts
  function resolveExecutables(str, component, nodeData, executables) {
    const parts = [];
    let lastIndex = 0;
    let isString = true;
    if (executables.length) {
      for (let { from, to, executable } of executables) {
        if (lastIndex !== from) {
          parts.push(str.slice(lastIndex, from));
        }
        lastIndex = to + 1;
        const res = evaluateStringInComponentContext(executable, component, nodeData);
        isString = isString && typeof res === "string";
        parts.push(res);
      }
      if (lastIndex !== str.length) {
        parts.push(str.slice(lastIndex));
      }
    } else {
      parts.push(str);
    }
    if (!isString && parts.length === 1) {
      return parts[0];
    }
    return parts.map(jsonStringify).join("");
  }

  // src/utils/convert-html-entities.ts
  var convertHtmlEntities = (str) => str.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&").replace(/&quot;/g, '"');

  // src/tracker/utils/extract-executable-snippet-from-string.ts
  function extractExecutableSnippetFromString(str, [start, end] = ["{", "}"], offset = 0) {
    const stack = [];
    const pattern = new RegExp(`[\\${start}\\${end}]`, "g");
    let snippets = [];
    let match;
    let startingCurlyIndex;
    while ((match = pattern.exec(str)) !== null) {
      const char = match[0];
      if (char === start) {
        stack.push(match.index);
      } else if (char === end && stack.length) {
        startingCurlyIndex = stack.pop();
        if (!stack.length) {
          const matchStr = str.slice(startingCurlyIndex + 1, match.index);
          if (matchStr) {
            for (let j = 0; j < snippets.length; j++) {
              const snippet = snippets[j];
              if (snippet.from - offset > startingCurlyIndex && snippet.to - offset < match.index) {
                snippets.splice(j, 1);
              }
            }
            snippets.push({
              from: startingCurlyIndex + offset,
              to: match.index + offset,
              match: `${start}${matchStr}${end}`,
              executable: convertHtmlEntities(matchStr)
            });
          }
        }
      }
    }
    return snippets;
  }

  // src/tags/slot.tag.ts
  var slotTag = (node, { component } = {}, cb) => {
    let nodes = [];
    if (component.type === "context") {
      nodes = renderCustomSlot(node, component.childNodes);
    } else {
      nodes = getSlotAssignedNodes(component.childNodes, node.getAttribute("name") || "");
    }
    cb(nodes);
  };
  function renderCustomSlot(node, childNodes) {
    const name = node.getAttribute("name") || "";
    let nodeList = getSlotAssignedNodes(childNodes, name);
    let comment = document.createComment(`slotted [${name || ""}]`);
    node.parentNode?.replaceChild(comment, node);
    if (!nodeList.length) {
      nodeList = Array.from(node.childNodes);
    }
    let anchor = comment;
    for (let n of nodeList) {
      anchor.after(n);
      anchor = n;
    }
    comment.parentNode?.removeChild(comment);
    return nodeList;
  }
  function getSlotAssignedNodes(childNodes = [], name = "") {
    if (name) {
      return childNodes.filter((n) => {
        return n.nodeType === 1 && n.getAttribute("slot") === name;
      });
    }
    return childNodes.filter((n) => {
      return n.nodeType !== 1 || !n.hasAttribute("slot");
    });
  }

  // src/tracker/utils/extract-executable-snippet-from-css.ts
  function extractExecutableSnippetFromCSS(css2) {
    const pattern = /[\{\}]/g;
    let snippets = [];
    const stack = [];
    let match;
    while ((match = pattern.exec(css2)) !== null) {
      const char = match[0];
      if (char === "{") {
        stack.push(match.index);
      } else if (char === "}") {
        if (stack.length === 1) {
          snippets.push(
            ...extractExecutableSnippetFromString(
              css2.slice(stack[0], match.index),
              ["[", "]"],
              stack[0]
            )
          );
        }
        stack.pop();
      }
    }
    return snippets;
  }

  // src/tracker/utils/parse-node-directive.ts
  function parseNodeDirective(node, name, value) {
    const dot = name.indexOf(".");
    let prop = null;
    if (dot >= 0) {
      prop = name.slice(dot + 1);
      name = name.slice(0, dot).toLowerCase();
    }
    return { name, value, prop };
  }

  // src/tracker/utils/get-event-handler-function.ts
  function getEventHandlerFunction(component, node, attribute) {
    let nodeData = $.get(node).$context;
    const props = Array.from(/* @__PURE__ */ new Set([...Object.getOwnPropertyNames(nodeData), ...component.$properties]));
    const value = attribute.value.trim();
    const match = value.match(/^(?:((?:this\.)?([a-z$_][a-z0-9$_\\.]*)\s*\((.*)\))|\{(.*)\})$/i);
    let func;
    if (match) {
      let [_, fn, fnName, fnArgs, executable] = match;
      if (executable) {
        func = new Function("$event", ...props, `"use strict";
 ${executable};`);
      } else {
        if (typeof component[fnName] === "function") {
          fn = fn.replace(/^this\./, "");
          func = new Function("$event", ...props, `"use strict";
 this.${fn}`);
        } else {
          func = new Function("$event", ...props, `"use strict";
 ${fn}`);
        }
      }
    } else {
      func = new Function("$event", ...props, `"use strict";
 ${value}`);
    }
    return (event) => {
      nodeData = $.get(node).$context;
      const values = props.map((k) => nodeData[k] ?? component[k] ?? null);
      func.call(component, event, ...values);
    };
  }

  // src/tracker/Track.ts
  var Track = class {
    constructor(name, value, type = 0 /* attribute */) {
      this.name = name;
      this.value = value;
      this.type = type;
      this.executables = [];
      this.handler = null;
      this.prop = null;
      this.prevValue = null;
    }
  };

  // src/tracker/track-node.ts
  var trackNode = (node, component) => {
    const tracks = {
      directive: [],
      attribute: [],
      property: []
    };
    defineNodeContextMetadata(node);
    $.get(node).rawNodeString = (node.nodeType === 3 ? node.nodeValue : node.outerHTML) || "";
    let { nodeName, nodeValue, nodeType, textContent, attributes } = node;
    let track = null;
    nodeValue = nodeValue || "";
    textContent = textContent || "";
    switch (nodeName) {
      case "#text":
        track = getNodeTrack("nodeValue", nodeValue);
        if (track) {
          tracks.property.push(track);
        }
        break;
      case "TEXTAREA":
        track = getNodeTrack("textContent", textContent);
        if (track) {
          tracks.property.push(track);
        }
        break;
      case "STYLE":
        track = getNodeTrack("textContent", textContent, 1 /* property */, extractExecutableSnippetFromCSS);
        if (track) {
          tracks.property.push(track);
        }
        break;
    }
    if (nodeType === 1) {
      const dirPattern = new RegExp(`^(${Object.keys(directiveRegistry).join("|")})\\.?`);
      const eventHandlers = [];
      const attrs = [];
      [...attributes].forEach((attr, i) => {
        if (dirPattern.test(attr.name)) {
          const { name, value, prop } = parseNodeDirective(node, attr.name, attr.value);
          const dir = directiveRegistry[name];
          track = new Track(name, convertHtmlEntities(value), 2 /* directive */);
          track.prop = prop;
          track.handler = dir;
          if (name === "if") {
            tracks.directive[0] = track;
          } else if (name === "repeat") {
            tracks.directive[1] = track;
          } else {
            tracks.directive[i + 2] = track;
          }
          node.removeAttribute(attr.name);
        } else if (attr.name.startsWith("on")) {
          eventHandlers.push({
            eventName: attr.name.slice(2).toLowerCase(),
            attribute: attr
          });
        } else {
          attrs.push(attr);
        }
      });
      tracks.directive = Object.values(tracks.directive);
      eventHandlers.forEach(({ eventName, fn, attribute }) => {
        node.removeAttribute(attribute.name);
        if (!fn) {
          node.addEventListener(eventName, getEventHandlerFunction(component, node, attribute));
        }
      });
      for (let attr of attrs) {
        if (attr.value.trim()) {
          track = getNodeTrack(attr.name, attr.value, 0 /* attribute */);
          if (track) {
            tracks.attribute.push(track);
          }
        }
      }
    }
    return tracks;
  };
  function getNodeTrack(name, value, type = 1 /* property */, extractor = extractExecutableSnippetFromString) {
    if ((value || "").trim()) {
      const track = new Track(name, value, type);
      track.executables = extractor(value);
      if (track.executables.length) {
        return track;
      }
    }
    return null;
  }

  // src/tracker/track-node-tree.ts
  var trackNodeTree = (node, ancestorNodeTrack, component) => {
    const { nodeName, nodeValue, childNodes, nodeType } = node;
    if ($.get(node)?.track) {
      ancestorNodeTrack.childNodeTracks.add($.get(node)?.track);
      return;
    }
    if (nodeType !== 11) {
      defineNodeContextMetadata(node);
    }
    if (nodeName === "#comment" || nodeName === "#text" && !nodeValue?.trim()) {
      return;
    }
    if (nodeName === "SLOT") {
      slotTag(node, {
        component: {
          type: component.customSlot ? "context" : "default",
          childNodes: component._childNodes
        }
      }, (nodes) => {
        nodes.forEach((node2) => {
          trackNodeTree(node2, ancestorNodeTrack, component);
        });
      });
    } else if (nodeType === 1 || nodeType === 3) {
      const tracks = trackNode(node, component);
      const isComponentNode = nodeName.includes("-");
      if (isComponentNode || (tracks.attribute.length || tracks.property.length || tracks.directive.length)) {
        const nodeTrack = new NodeTrack(node, component, tracks);
        $.get(node).track = nodeTrack;
        ancestorNodeTrack.childNodeTracks.add(nodeTrack);
        ancestorNodeTrack = nodeTrack;
      }
      if (/SCRIPT|STYLE|TEXTAREA|#text/i.test(nodeName)) {
        return;
      }
    }
    Array.from(childNodes).forEach((c) => trackNodeTree(c, ancestorNodeTrack, component));
  };

  // src/tracker/NodeTrack.ts
  var _compiled;
  var _NodeTrack = class {
    constructor(node, component, tracks = { directive: [], attribute: [], property: [] }) {
      this.node = node;
      this.component = component;
      this.tracks = tracks;
      __privateAdd(this, _compiled, false);
      this.childNodeTracks = /* @__PURE__ */ new Set();
      this.anchorNodeTrack = null;
      this.anchorTrack = null;
      this.dirs = /* @__PURE__ */ new WeakMap();
      this.dirAnchors = /* @__PURE__ */ new WeakMap();
      defineNodeContextMetadata(node);
      if (node.nodeType !== 8) {
        this.anchorNodeTrack = new _NodeTrack(document.createComment($.get(node).rawNodeString), component);
      }
      this.anchor = node;
    }
    get $context() {
      return (this.anchor === this.node ? $.get(this.node).$context : $.get(
        Array.isArray(this.anchor) ? this.anchor[0] : this.anchor
      )?.$context) || {};
    }
    get compiled() {
      return __privateGet(this, _compiled);
    }
    updateNode(force = false) {
      if (this.node.nodeType === 3) {
        for (let t of this.tracks.property) {
          this._updateNodeProperty(t);
        }
      } else {
        const empty = !this.tracks.directive.length && !this.tracks.attribute.length && !this.tracks.property.length;
        for (let t of this.tracks.directive) {
          const dirNode = this._updateNodeDirective(t);
          if (dirNode) {
            this._swapNodeAndDirNode(dirNode);
            this.anchor = !Array.isArray(dirNode) || dirNode.length ? dirNode : this.anchorNodeTrack?.node;
            if (dirNode !== this.node) {
              return;
            }
          }
        }
        for (let t of this.tracks.attribute) {
          this._updateNodeAttribute(t);
        }
        for (let t of this.tracks.property) {
          this._updateNodeProperty(t);
        }
        if (empty && force && this.node.nodeName.includes("-") && typeof this.node.forceUpdate == "function") {
          this.node.forceUpdate(force);
        }
        this.childNodeTracks.forEach((t) => {
          t.updateNode(force);
        });
      }
      __privateSet(this, _compiled, true);
    }
    _removeNodeDirectiveAttribute(n) {
      if (n.nodeType === 1) {
        n.removeAttribute(this.anchorTrack?.name || "");
      }
    }
    _updateNodeProperty(track) {
      const newValue = resolveExecutables(
        track.value,
        this.component,
        this.$context,
        track.executables
      );
      if (!isPrimitive(newValue) || newValue !== this.node[track.name]) {
        this.node[track.name] = newValue;
        return true;
      }
      return false;
    }
    _updateNodeAttribute(track) {
      let newValue = resolveExecutables(
        track.value,
        this.component,
        this.$context,
        track.executables
      );
      const { attrPropsMap } = $.get(this.node);
      const attrProp = attrPropsMap ? attrPropsMap[track.name] : track.name;
      if (isPrimitive(newValue)) {
        if (this.node.getAttribute(track.name) !== newValue) {
          this.node.setAttribute(track.name, newValue);
          if (!this.node.nodeName.includes("-")) {
            this.node[attrProp] = newValue;
          }
          return true;
        }
      } else {
        if (this.node.hasAttribute(track.name)) {
          $.get(this.node).clearAttr = true;
          this.node.removeAttribute(track.name);
        }
        this.node[attrProp] = newValue;
        return true;
      }
      return false;
    }
    _updateNodeDirective(track) {
      if (track.handler) {
        const { handler } = track;
        const dir = this.dirs.get(track) || new handler(this.component);
        this.dirs.set(track, dir);
        let val = dir.parseValue(track.value, track.prop);
        let value = resolveExecutables(
          val,
          this.component,
          this.$context,
          extractExecutableSnippetFromString(val)
        );
        if (typeof value === "string") {
          value = evaluateStringInComponentContext(value, this.component, this.$context);
        }
        if (track.prevValue !== value) {
          track.prevValue = value;
          const dirNode = dir.render(value, {
            element: this.node,
            anchorNode: this.dirAnchors.get(track) ?? null,
            rawElementOuterHTML: $.get(this.node).rawNodeString
          });
          if (dirNode !== this.node) {
            this.dirAnchors.set(track, dirNode);
            this.anchorTrack = track;
          }
          return dirNode;
        } else if (this.anchorTrack === track) {
          return this.anchor;
        }
        this.dirAnchors.set(track, null);
      }
      return this.node;
    }
    _swapNodeAndDirNode(dirNode) {
      if (dirNode === this.anchor) {
        return;
      }
      this.anchorNodeTrack?.childNodeTracks.clear();
      if (Array.isArray(dirNode)) {
        dirNode.forEach((n) => {
          this._removeNodeDirectiveAttribute(n);
          trackNodeTree(n, this.anchorNodeTrack, this.component);
        });
      } else {
        this._removeNodeDirectiveAttribute(dirNode);
        trackNodeTree(dirNode, this.anchorNodeTrack, this.component);
      }
      let dirIsArray = Array.isArray(dirNode);
      if (dirIsArray && !dirNode.length || !dirIsArray && !/[831]/.test(`${dirNode.nodeType}`)) {
        dirNode = this.anchorNodeTrack.node;
        dirIsArray = false;
      }
      const anchorIsArray = Array.isArray(this.anchor);
      const anchorEl = anchorIsArray && !this.anchor.length ? this.anchorNodeTrack.node : document.createComment("cw");
      let nextEl = anchorEl;
      if (anchorIsArray) {
        const el = !this.anchor.length ? this.anchorNodeTrack.node : this.anchor[0];
        el?.parentNode?.insertBefore(nextEl, el);
      } else {
        this.anchor.parentNode?.insertBefore(nextEl, this.anchor);
      }
      if (dirIsArray) {
        for (let el of dirNode) {
          if (!el.isConnected) {
            nextEl.after(el);
          }
          nextEl = el;
        }
      } else if (dirNode instanceof Node) {
        nextEl.after(dirNode);
      }
      if (dirNode !== this.node) {
        this.anchorNodeTrack?.childNodeTracks.forEach((t) => {
          t.updateNode();
        });
      }
      if (anchorIsArray) {
        for (let el of this.anchor) {
          if (!dirIsArray || !dirNode.includes(el)) {
            el.parentNode?.removeChild(el);
          }
        }
      } else if (this.anchor !== dirNode) {
        this.anchor.parentNode?.removeChild(this.anchor);
      }
      anchorEl.parentNode?.removeChild(anchorEl);
    }
  };
  var NodeTrack = _NodeTrack;
  _compiled = new WeakMap();

  // src/core/utils/json-to-css.ts
  function JSONToCSS(obj, tagName, hasShadowRoot = true) {
    const css2 = Object.keys(obj).map((prop) => createPropertyBody(prop, obj[prop])).join("").trim();
    if (!hasShadowRoot) {
      return replaceHost(css2, tagName);
    }
    return css2;
  }
  function getPropertyCSS(prop, value, parentProp, cb) {
    prop = prop.trim();
    if (prop.startsWith("&")) {
      cb(null, createPropertyBody(prop.replace(/&/g, parentProp), value));
    } else if (prop.startsWith("@")) {
      cb(null, createPropertyBody(prop, value));
    } else if (typeof value === "object") {
      if (parentProp.startsWith("@")) {
        cb(createPropertyBody(prop, value));
      } else if (/^[^+~>]/i.test(prop)) {
        const selector = parentProp.split(",").map((pp) => prop.split(",").map((p) => `${pp.trim()} ${p.trim()}`).join(", ")).join(", ").trim();
        cb(null, createPropertyBody(selector, value));
      }
    } else {
      cb(`${turnCamelToKebabCasing(prop)}: ${value};`);
    }
  }
  function createPropertyBody(prop, value) {
    const declarations = [];
    let declaration = `${prop} {`;
    Object.keys(value).forEach((childProp) => getPropertyCSS(childProp, value[childProp], prop, (pair, newDeclaration = "") => {
      if (pair) {
        declaration += pair;
      } else {
        declarations.push(newDeclaration);
      }
    }));
    declaration += "} ";
    declarations.unshift(declaration);
    return declarations.join("");
  }

  // src/utils/get-node-path-to-doc.ts
  var getNodePathToDoc = (node) => {
    const parent = getParent(node);
    if (parent && parent.nodeName !== "BODY" && parent.nodeName !== "HEAD") {
      return [...getNodePathToDoc(parent), node.nodeName];
    }
    return [node.nodeName];
  };

  // src/core/WebComponent.ts
  var WebComponent = class extends HTMLElement {
    constructor() {
      super();
      this.$refs = {};
      this.$properties = ["$context", "$refs", "templateId", "_childNodes", "$properties"];
      this.templateId = "";
      this._childNodes = [];
      let { mode, observedAttributes, delegatesFocus } = this.constructor;
      const selfTrack = new NodeTrack(this, this);
      const meta = $.get(this);
      meta.root = this;
      meta.parsed = false;
      meta.clearAttr = false;
      meta.selfTrack = selfTrack;
      meta.externalNodes = [];
      meta.attrPropsMap = observedAttributes.reduce((map, attr) => ({
        ...map,
        [attr]: turnKebabToCamelCasing(attr)
      }), {});
      meta.mountUnsubscribe = () => {
      };
      if (mode !== "none") {
        $.get(this).root = this.attachShadow({ mode, delegatesFocus });
      }
    }
    static parseHTML(markup) {
      return parse(markup);
    }
    static register(tagName) {
      if (this.name !== "WebComponent") {
        tagName = typeof tagName === "string" && tagName ? tagName : typeof this.tagName === "string" && this.tagName ? this.tagName : turnCamelToKebabCasing(this.name);
        this.tagName = tagName;
        if (!customElements.get(tagName)) {
          customElements.define(tagName, this);
        }
        return;
      }
      console.warn("Can't 'register' 'WebComponent' class itself");
    }
    static registerAll(comps) {
      if (this.name === "WebComponent") {
        return comps.forEach((comp) => comp.register());
      }
      console.warn("Please use 'WebComponent' to 'registerAll'");
    }
    static get isRegistered() {
      return customElements.get(this.tagName) !== void 0;
    }
    get template() {
      return "";
    }
    get stylesheet() {
      return "";
    }
    get customSlot() {
      return false;
    }
    get root() {
      return this.constructor.mode === "closed" ? null : $.get(this).root;
    }
    get mounted() {
      return this.isConnected;
    }
    get parsed() {
      return $.get(this).parsed;
    }
    get $context() {
      return $.get(this).$context;
    }
    updateContext(ctx) {
      const { oldCtx, newCtx } = $.get(this).updateContext(ctx);
      this.forceUpdate(true);
      this.onUpdate("$context", oldCtx, newCtx);
    }
    connectedCallback() {
      const { initialContext, observedAttributes, tagName, mode } = this.constructor;
      const { parsed, selfTrack, root, attrPropsMap } = $.get(this);
      if (Object.keys(initialContext).length) {
        $.get(this).updateContext(initialContext);
      }
      const onPropUpdate = (prop, oldValue, newValue) => {
        if (this.mounted) {
          try {
            this.forceUpdate();
            this.onUpdate(prop, oldValue, newValue);
          } catch (e) {
            this.onError(e.message);
          }
        } else if (this.parsed) {
          this.onError(`Cannot set property "${prop}" on unmounted component. Possibly a memory leak in [ ${getNodePathToDoc(this).join(" > ")} ]`);
        }
      };
      try {
        if (parsed) {
          this.updateContext({});
        } else {
          this.$properties.push(
            ...setComponentPropertiesFromObservedAttributes(this, observedAttributes, attrPropsMap, onPropUpdate),
            ...setupComponentPropertiesForAutoUpdate(this, onPropUpdate)
          );
          Object.freeze(this.$properties);
          const hasShadowRoot = this.constructor.mode !== "none";
          const stylesheet = this.stylesheet;
          let temp = this.template;
          let style = "";
          if (!temp && this.templateId) {
            const t = document.getElementById(this.templateId);
            temp = t?.nodeName === "TEMPLATE" ? t.innerHTML : temp;
          }
          if (stylesheet && mode !== "none" || !getLinkAndStyleTagsFromHead(tagName).length) {
            style = typeof stylesheet === "object" ? `<style class="${tagName}">${JSONToCSS(stylesheet, tagName.toLowerCase(), hasShadowRoot)}</style>` : getStyleString(stylesheet, tagName.toLowerCase(), hasShadowRoot);
          }
          const contentNode = parse(resolveHtmlEntities(style + temp));
          this._childNodes = Array.from(this.childNodes);
          if (this.customSlot) {
            this.innerHTML = "";
          }
          trackNodeTree(contentNode, selfTrack, this);
          selfTrack.childNodeTracks.forEach((t) => {
            t.updateNode();
          });
          if (mode === "none") {
            [
              ...Array.from(contentNode.querySelectorAll("link")),
              ...Array.from(contentNode.querySelectorAll("style"))
            ].forEach((el) => {
              document.head.appendChild(el);
              $.get(this).externalNodes.push(el);
            });
          }
          $.get(this).parsed = true;
          root.appendChild(contentNode);
        }
        $.get(this).mountUnsubscribe = this.onMount();
      } catch (e) {
        this.onError(e.message);
      }
    }
    onMount() {
    }
    disconnectedCallback() {
      try {
        const { mountUnsubscribe } = $.get(this);
        typeof mountUnsubscribe === "function" && mountUnsubscribe();
        this.onDestroy();
      } catch (e) {
        this.onError(e.message);
      }
    }
    onDestroy() {
    }
    attributeChangedCallback(name, oldValue, newValue) {
      if ($.get(this).clearAttr) {
        $.get(this).clearAttr = false;
      } else if (this.mounted) {
        try {
          if (!(name.startsWith("data-") || name === "class" || name === "style")) {
            const prop = $.get(this).attrPropsMap[name];
            this[prop] = boolean_attributes_default.hasOwnProperty(prop) ? this.hasAttribute(name) : jsonParse(newValue);
          } else {
            this.forceUpdate();
            this.onUpdate(name, oldValue, newValue);
          }
        } catch (e) {
          this.onError(e.message);
        }
      }
    }
    onUpdate(name, oldValue, newValue) {
    }
    forceUpdate(deep = false) {
      $.get(this).selfTrack.childNodeTracks.forEach((t) => {
        t.updateNode(deep);
      });
    }
    adoptedCallback() {
      try {
        this.onAdoption();
      } catch (e) {
        this.onError(e.message);
      }
    }
    onAdoption() {
    }
    onError(errorMessage) {
      console.error(this.constructor.name, errorMessage);
    }
  };
  WebComponent.observedAttributes = [];
  WebComponent.mode = "open" /* OPEN */;
  WebComponent.delegatesFocus = false;
  WebComponent.tagName = "";
  WebComponent.initialContext = {};
  function getLinkAndStyleTagsFromHead(tagName) {
    return [
      ...Array.from(document.head.querySelectorAll(`link.${tagName}`.toLowerCase())),
      ...Array.from(document.head.querySelectorAll(`style.${tagName}`.toLowerCase()))
    ];
  }

  // src/core/ContextProviderComponent.ts
  var ContextProviderComponent = class extends WebComponent {
    get customSlot() {
      return true;
    }
    get template() {
      return "<slot></slot>";
    }
    get stylesheet() {
      return ":host { display: block; }";
    }
  };
  ContextProviderComponent.mode = "none" /* NONE */;

  // src/utils/html.ts
  var html = (x) => x.join("");

  // src/utils/css.ts
  var css = (x) => x.join("");

  // src/utils/raw.ts
  var raw = (data) => data.__isProxy ? data.__raw : data;

  // src/utils/is-proxy.ts
  var isProxy = (data) => data.__isProxy ?? false;

  // src/client.ts
  if (window) {
    window.WebComponent = WebComponent;
    window.ContextProviderComponent = ContextProviderComponent;
    window.Directive = Directive;
    window.html = html;
    window.css = css;
    window.raw = raw;
    window.isProxy = isProxy;
  }
})();
