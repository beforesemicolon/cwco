(() => {
  // src/directives/registry.ts
  var directiveRegistry = {};

  // src/metadata.ts
  var $ = /* @__PURE__ */ new WeakMap();

  // src/utils/define-node-context-metadata.ts
  function defineNodeContextMetadata(node) {
    if ($.has(node) && $.get(node)?.$context) {
      return;
    }
    let ctx = proxyCtx({}, node);
    let subs = [];
    const dt = $.get(node) || {};
    dt.subscribe = (cb) => {
      subs.push(cb);
      return () => {
        subs = subs.filter((c) => c !== cb);
      };
    };
    dt.updateContext = (newCtx = null) => {
      if (newCtx && typeof newCtx === "object") {
        ctx = proxyCtx({ ...ctx, ...newCtx }, node);
      }
      $.get(node)?.track?.updateNode();
      notify();
    };
    Object.defineProperty(dt, "$context", {
      get() {
        return ctx;
      }
    });
    function notify() {
      (node.root ?? node).childNodes.forEach((n) => {
        if (typeof $.get(n)?.updateContext === "function") {
          $.get(n).updateContext();
        }
      });
      subs.forEach((cb) => {
        cb(dt.$context);
      });
    }
    $.set(node, dt);
  }
  function getParent(node) {
    return node.parentNode instanceof ShadowRoot ? node.parentNode.host : node.parentNode;
  }
  function proxyCtx(obj, node) {
    let keys = Object.keys(obj);
    return new Proxy(obj, {
      get(obj2, n) {
        let res = Reflect.get(obj2, n);
        return res ?? Reflect.get($.get(getParent(node))?.$context ?? {}, n);
      },
      ownKeys() {
        return Array.from(/* @__PURE__ */ new Set([
          ...keys,
          ...Reflect.ownKeys($.get(getParent(node))?.$context ?? {})
        ]));
      }
    });
  }

  // src/directive.ts
  var Directive = class {
    constructor(component) {
      $.set(this, { component });
    }
    static register(name = "") {
      name = (name || this.name).toLowerCase();
      if (directiveRegistry[name] === void 0) {
        directiveRegistry[name] = this;
      }
    }
    parseValue(value, prop) {
      return value;
    }
    render(val, { element }) {
      return element;
    }
    setRef(name, node) {
      const currRef = $.get(this).component.$refs[name];
      if (currRef !== void 0) {
        if (Array.isArray(currRef)) {
          currRef.push(node);
        } else {
          $.get(this).component.$refs[name] = [currRef, node];
        }
      } else {
        $.get(this).component.$refs[name] = node;
      }
    }
    getContext(node) {
      return $.get(node).$context ?? null;
    }
    updateContext(node, newCtx) {
      defineNodeContextMetadata(node);
      $.get(node)?.updateContext(newCtx);
    }
  };

  // src/directives/if.directive.ts
  var If = class extends Directive {
    render(condition, { element, anchorNode }) {
      return condition ? element : anchorNode || new Comment(` if: ${condition} `);
    }
  };

  // src/directives/ref.directive.ts
  var Ref = class extends Directive {
    parseValue(value) {
      return `"${value}"`;
    }
    render(name, { element }) {
      if (/^[a-z$_][a-z0-9$_]*$/i.test(name)) {
        this.setRef(name, element);
        return element;
      }
      throw new Error(`Invalid "ref" property name "${name}"`);
    }
  };

  // src/utils/turn-kebab-to-camel-casing.ts
  function turnKebabToCamelCasing(name) {
    return name.split(/-+/).map((part, i) => i === 0 && part.length > 1 ? part : part[0].toUpperCase() + part.slice(1)).join("") ?? name;
  }

  // src/utils/turn-camel-to-kebab-casing.ts
  function turnCamelToKebabCasing(name) {
    return name.match(/(?:[A-Z]+(?=[A-Z][a-z])|[A-Z]+|[a-zA-Z])[a-z]*/g)?.map((p) => p.toLowerCase()).join("-") ?? name;
  }

  // src/utils/boolean-attributes.json
  var allowfullscreen = {
    value: false,
    name: "allowFullscreen"
  };
  var allowpaymentrequest = {
    value: false,
    name: "allowPaymentRequest"
  };
  var async = {
    value: false,
    name: "async"
  };
  var autofocus = {
    value: false,
    name: "autofocus"
  };
  var autoplay = {
    value: false,
    name: "autoplay"
  };
  var checked = {
    value: false,
    name: "checked"
  };
  var controls = {
    value: false,
    name: "controls"
  };
  var default2 = {
    value: false,
    name: "default"
  };
  var defer = {
    value: false,
    name: "defer"
  };
  var disabled = {
    value: false,
    name: "disabled"
  };
  var formnovlidate = {
    value: false,
    name: "formNoValidate"
  };
  var hidden = {
    value: false,
    name: "hidden"
  };
  var ismap = {
    value: false,
    name: "isMap"
  };
  var itemscope = {
    value: false,
    name: "itemScope"
  };
  var loop = {
    value: false,
    name: "loop"
  };
  var multiple = {
    value: false,
    name: "multiple"
  };
  var muted = {
    value: false,
    name: "muted"
  };
  var nomodule = {
    value: false,
    name: "noModule"
  };
  var novalidate = {
    value: false,
    name: "novalidate"
  };
  var open = {
    value: false,
    name: "open"
  };
  var playsinline = {
    value: false,
    name: "playsInline"
  };
  var readonly = {
    value: false,
    name: "readonly"
  };
  var required = {
    value: false,
    name: "required"
  };
  var reversed = {
    value: false,
    name: "reversed"
  };
  var selected = {
    value: false,
    name: "selected"
  };
  var truspeed = {
    value: false,
    name: "truSpeed"
  };
  var boolean_attributes_default = {
    allowfullscreen,
    allowpaymentrequest,
    async,
    autofocus,
    autoplay,
    checked,
    controls,
    default: default2,
    defer,
    disabled,
    formnovlidate,
    hidden,
    ismap,
    itemscope,
    loop,
    multiple,
    muted,
    nomodule,
    novalidate,
    open,
    playsinline,
    readonly,
    required,
    reversed,
    selected,
    truspeed
  };

  // src/directives/attr.directive.ts
  var Attr = class extends Directive {
    parseValue(value, prop) {
      let [attrName, property = null] = (prop ?? "").split(".");
      const commaIdx = value.lastIndexOf(",");
      return `["${attrName}", "${property || ""}", ${commaIdx >= 0 ? value.slice(commaIdx + 1).trim() : value}, "${commaIdx >= 0 ? value.slice(0, commaIdx).trim() : ""}"]`;
    }
    render([attrName, property, shouldAdd, val], { element }) {
      switch (attrName) {
        case "style":
          if (property) {
            property = turnKebabToCamelCasing(property);
            element.style[property] = shouldAdd ? val : "";
          } else {
            val.match(/([a-z][a-z-]+)(?=:):([^;]+)/g)?.forEach((style) => {
              let [name, styleValue] = style.split(":").map((s) => s.trim());
              if (shouldAdd) {
                element.style.setProperty(name, styleValue);
              } else {
                element.setAttribute("style", element.style.cssText.replace(new RegExp(`${name}\\s*:\\s*${styleValue};?`, "g"), ""));
              }
            });
          }
          break;
        case "class":
          if (property) {
            if (shouldAdd) {
              element.classList.add(property);
            } else {
              element.classList.remove(property);
            }
          } else {
            const classes = val.split(/\s+/g);
            if (shouldAdd) {
              classes.forEach((cls) => element.classList.add(cls));
            } else {
              classes.forEach((cls) => element.classList.remove(cls));
            }
          }
          break;
        case "data":
          if (property) {
            if (shouldAdd) {
              element.dataset[turnKebabToCamelCasing(property)] = val;
            } else {
              element.removeAttribute(`data-${turnCamelToKebabCasing(property)}`);
            }
          }
          break;
        default:
          if (attrName) {
            if (shouldAdd) {
              element.setAttribute(attrName, boolean_attributes_default.hasOwnProperty(attrName) ? "" : `${val || shouldAdd}`);
            } else {
              element.removeAttribute(attrName);
            }
          }
      }
      return element;
    }
  };

  // src/utils/self-closing-tags.json
  var AREA = "AREA";
  var META = "META";
  var BASE = "BASE";
  var BR = "BR";
  var COL = "COL";
  var EMBED = "EMBED";
  var HR = "HR";
  var IMG = "IMG";
  var INPUT = "INPUT";
  var LINK = "LINK";
  var PARAM = "PARAM";
  var SOURCE = "SOURCE";
  var TRACK = "TRACK";
  var WBR = "WBR";
  var COMMAND = "COMMAND";
  var KEYGEN = "KEYGEN";
  var MENUITEM = "MENUITEM";
  var DOCTYPE = "DOCTYPE";
  var _DOCTYPE = "!DOCTYPE";
  var self_closing_tags_default = {
    AREA,
    META,
    BASE,
    BR,
    COL,
    EMBED,
    HR,
    IMG,
    INPUT,
    LINK,
    PARAM,
    SOURCE,
    TRACK,
    WBR,
    COMMAND,
    KEYGEN,
    MENUITEM,
    DOCTYPE,
    "!DOCTYPE": _DOCTYPE
  };

  // src/utils/parse.ts
  function parse(markup) {
    const tagCommentPattern = /<!--([^]*?)-->|<(\/|!)?([a-z][\w-.:]*)((?:\s*[a-z][\w-.:]*(?:\s*=\s*(?:"[^"]*"|'[^']*'))?)+\s*|\s*)(\/?)>/ig;
    const root = document.createDocumentFragment();
    const stack = [root];
    let match = null;
    let lastIndex = 0;
    while ((match = tagCommentPattern.exec(markup)) !== null) {
      let [fullMatch, comment, closeOrBangSymbol, tagName, attributes, selfCloseSlash] = match;
      tagName = tagName?.toUpperCase();
      if (closeOrBangSymbol === "!") {
        continue;
      }
      const parentNode = stack[stack.length - 1] || null;
      if (lastIndex !== match.index) {
        const textNode = document.createTextNode(markup.slice(lastIndex, match.index));
        parentNode.appendChild(textNode);
      }
      lastIndex = tagCommentPattern.lastIndex;
      if (comment) {
        const commentNode = document.createComment(comment);
        parentNode.appendChild(commentNode);
        continue;
      }
      if (selfCloseSlash || self_closing_tags_default[tagName]) {
        const node = document.createElement(tagName);
        setAttributes(node, attributes);
        parentNode.appendChild(node);
      } else if (closeOrBangSymbol === "/") {
        stack.pop();
      } else if (!closeOrBangSymbol) {
        const node = document.createElement(tagName);
        setAttributes(node, attributes);
        parentNode.appendChild(node);
        stack.push(node);
      }
    }
    if (lastIndex < markup.length) {
      const textNode = document.createTextNode(markup.slice(lastIndex));
      root.appendChild(textNode);
    }
    return root;
  }
  function setAttributes(node, attributes) {
    const attrPattern = /([a-z][\w-.:]*)(?:\s*=\s*(?:"([^"]*)"|'([^']*)'|(\S+)))?/ig;
    let match = null;
    while (match = attrPattern.exec(attributes)) {
      let name = match[1];
      const value = match[2] || match[3] || match[4] || (new RegExp(`^${match[1]}\\s*=`).test(match[0]) ? "" : null);
      node.setAttribute(name, value ?? "");
    }
  }

  // src/directives/repeat.directive.ts
  var Repeat = class extends Directive {
    parseValue(value) {
      const idx = value.lastIndexOf(";");
      let iPart = value;
      let kPart = "";
      if (idx > 0) {
        iPart = value.slice(0, idx);
        kPart = value.slice(idx + 1);
      }
      const [v, vAs = "$item"] = `${iPart} `.split(/\s+as\s+/g).map((s) => s.trim());
      const [k, kAs = "$key"] = `${kPart} `.split(/\s+as\s+/g).map((s) => s.trim());
      return `[${v}, "${vAs}", "${k === "$key" ? kAs : ""}"]`;
    }
    render([repeatData, vAs, kAs], { element, rawElementOuterHTML, anchorNode }) {
      anchorNode = anchorNode ?? [];
      const list = [];
      if (element.nodeType === 1) {
        let times;
        if (Number.isInteger(repeatData)) {
          times = repeatData;
        } else {
          repeatData = repeatData instanceof Set ? Object.entries(Array.from(repeatData)) : repeatData instanceof Map ? Array.from(repeatData.entries()) : repeatData[Symbol.iterator] ? Object.entries([...repeatData]) : Object.entries(repeatData);
          times = repeatData.length;
        }
        for (let index = 0; index < times; index++) {
          if (anchorNode[index]) {
            this.updateNodeContext(anchorNode[index], index, vAs, kAs, repeatData);
            list.push(anchorNode[index]);
            continue;
          }
          const el = this.cloneRepeatedNode(rawElementOuterHTML);
          this.updateNodeContext(el, index, vAs, kAs, repeatData);
          list.push(el);
        }
      }
      return list;
    }
    updateNodeContext(el, index, vAs, kAs, list = []) {
      const [key, value] = list[index] ?? [index, index + 1];
      this.updateContext(el, {
        [vAs || "$item"]: value,
        [kAs || "$key"]: key
      });
    }
    cloneRepeatedNode(rawElementOuterHTML) {
      const clone = parse(rawElementOuterHTML).children[0];
      clone.removeAttribute("repeat");
      clone.removeAttribute("if");
      return clone;
    }
  };

  // src/directives/index.ts
  If.register("if");
  Ref.register("ref");
  Attr.register("attr");
  Repeat.register("repeat");
  var directives = /* @__PURE__ */ new Set([
    If.name.toLowerCase(),
    Ref.name.toLowerCase(),
    Attr.name.toLowerCase(),
    Repeat.name.toLowerCase()
  ]);

  // src/utils/proxify.ts
  function proxify(name, object, notify = () => {
  }, self = null) {
    self = self ?? object;
    if (!object || object.__proxy__ || /number|function|string|bigint|boolean/.test(typeof object) || [String, Number, Boolean, BigInt].some((o) => object instanceof o)) {
      return object;
    }
    return new Proxy(object, {
      get(obj, n) {
        let res = Reflect.get(obj, n);
        if (res) {
          if (typeof res === "object") {
            return proxify(name, res, notify, self);
          }
          if (typeof res === "function") {
            if (typeof n !== "symbol") {
              if (/forEach/.test(n)) {
                return (cb, thisArg) => {
                  obj[n]((v, k, l) => {
                    cb.call(thisArg ?? obj, proxify(name, v, notify, self), k, l);
                  }, thisArg ?? obj);
                };
              } else if (/values|entries|keys/.test(n)) {
                return () => ({
                  *[Symbol.iterator]() {
                    if (n === "entries") {
                      for (const [k, v] of obj[n]()) {
                        yield [proxify(name, k, notify, self), proxify(name, v, notify, self)];
                      }
                    } else {
                      for (const v of obj[n]()) {
                        yield proxify(name, v, notify, self);
                      }
                    }
                  }
                });
              }
              return (...args) => {
                const r = res.apply(obj, args);
                if (typeof r === "object" && (Array.isArray(obj) && /at|find/.test(n) || obj instanceof Map && /get/.test(n) || obj instanceof WeakMap && /get/.test(n))) {
                  return proxify(name, r, notify, self);
                }
                if (Array.isArray(obj) && /push|pop|splice|shift|unshift|reverse|sort|fill|copyWithin/.test(n) || obj instanceof Map && /set|delete|clear/.test(n) || obj instanceof Set && /add|delete|clear/.test(n) || obj instanceof WeakSet && /add|delete/.test(n) || obj instanceof WeakMap && /set|delete/.test(n)) {
                  notify(name, self);
                }
                return r;
              };
            } else {
              res = res.bind(obj);
            }
          }
        }
        return res;
      },
      set(obj, n, value) {
        const res = Reflect.set(obj, n, value);
        notify(name, self);
        return res;
      },
      deleteProperty(target, p) {
        const res = Reflect.deleteProperty(target, p);
        notify(name, self);
        return res;
      },
      defineProperty(target, p, attributes) {
        const res = Reflect.defineProperty(target, p, attributes);
        notify(name, self);
        return res;
      }
    });
  }

  // src/utils/json-parse.ts
  function jsonParse(value) {
    if (value && typeof value === "string") {
      try {
        value = JSON.parse(value.replace(/['`]/g, '"'));
      } catch (e) {
      }
    }
    return value;
  }

  // src/utils/set-component-properties-from-observed-attributes.ts
  function setComponentPropertiesFromObservedAttributes(comp, attrs, attrsMap = {}, cb) {
    const properties = [];
    attrs.forEach((attr) => {
      attr = attr.trim();
      if (!directives.has(attr) && !(attr.startsWith("data-") || attr === "class" || attr === "style")) {
        let prop = attrsMap[attr];
        let value = comp.getAttribute(attr) ?? comp[prop] ?? "";
        properties.push(prop);
        value = proxify(prop, jsonParse(value), (name, val) => {
          cb(name, val, val);
        });
        if (boolean_attributes_default.hasOwnProperty(prop)) {
          value = comp.hasAttribute(attr);
          prop = boolean_attributes_default[prop].name;
        }
        if (value && typeof value === "object") {
          comp.removeAttribute(attr);
        }
        Object.defineProperty(comp, prop, {
          get() {
            return value;
          },
          set(newValue) {
            if (comp.hasAttribute(attr) && typeof newValue === "object") {
              $.get(comp).clearAttr = true;
              comp.removeAttribute(attr);
            }
            if (value !== newValue) {
              const oldValue = value;
              value = proxify(prop, newValue, () => {
                cb(prop, oldValue, value);
              });
              cb(prop, oldValue, newValue);
            }
          }
        });
      }
    });
    return properties;
  }

  // src/utils/setup-component-properties-for-auto-update.ts
  function setupComponentPropertiesForAutoUpdate(component, onUpdate) {
    const properties = [];
    for (let property of Object.getOwnPropertyNames(component)) {
      const attr = turnCamelToKebabCasing(property);
      if (!directives.has(property) && !/\$|_/.test(property[0]) && !component.constructor.observedAttributes.includes(attr)) {
        let value = component[property];
        properties.push(property);
        value = proxify(property, value, () => {
          onUpdate(property, value, value);
        });
        Object.defineProperty(component, property, {
          get() {
            return value;
          },
          set(newValue) {
            const oldValue = value;
            value = proxify(property, newValue, () => {
              onUpdate(property, oldValue, value);
            });
            if (newValue !== oldValue) {
              onUpdate(property, oldValue, newValue);
            }
          }
        });
      }
    }
    return properties;
  }

  // src/utils/get-style-string.ts
  function getStyleString(stylesheet, tagName, hasShadowRoot = true) {
    stylesheet = stylesheet.trim().replace(/\s{2,}/g, " ");
    if (!stylesheet) {
      return "";
    }
    let style = stylesheet.startsWith("<style") ? stylesheet : `<style>${stylesheet}</style>`;
    const div = document.createElement("div");
    if (!hasShadowRoot) {
      style = style.replace(/(:host)((\s*\(.*\)|))?/g, (_, h, s) => {
        if (s) {
          return tagName + s.trim().slice(1, -1).trim();
        }
        return tagName;
      });
    }
    div.innerHTML = style;
    Array.from(div.children).forEach((child) => {
      child.className = tagName;
    });
    return div.innerHTML;
  }

  // src/utils/extract-executable-snippet-from-string.ts
  function extractExecutableSnippetFromString(str, [start, end] = ["{", "}"]) {
    const stack = [];
    const pattern = new RegExp(`[\\${start}\\${end}]`, "g");
    let snippets = [];
    let match;
    let startingCurlyIndex;
    while ((match = pattern.exec(str)) !== null) {
      const char = match[0];
      if (char === start) {
        stack.push(match.index);
      } else if (char === end && stack.length) {
        startingCurlyIndex = stack.pop();
        const matchStr = str.slice(startingCurlyIndex + 1, match.index);
        if (matchStr) {
          for (let j = 0; j < snippets.length; j++) {
            const snippet = snippets[j];
            if (snippet.from > startingCurlyIndex && snippet.to < match.index) {
              snippets.splice(j, 1);
            }
          }
          snippets.push({
            from: startingCurlyIndex,
            to: match.index,
            match: `${start}${matchStr}${end}`,
            executable: matchStr
          });
        }
      }
    }
    return snippets;
  }

  // src/utils/parse-node-directive.ts
  function parseNodeDirective(node, name, value) {
    const dot = name.indexOf(".");
    let prop = null;
    if (dot >= 0) {
      prop = name.slice(dot + 1);
      name = name.slice(0, dot);
    }
    return { name, value, prop };
  }

  // src/utils/evaluate-string-in-component-context.ts
  function evaluateStringInComponentContext(executable, component, nodeData = {}) {
    if (!executable.trim()) {
      return "";
    }
    const ctx = component.$context;
    const keys = Array.from(/* @__PURE__ */ new Set([
      ...Object.getOwnPropertyNames(nodeData),
      ...Object.getOwnPropertyNames(ctx),
      ...component.$properties
    ]));
    return new Function(...keys, `"use strict";
 return ${executable};`).apply(component, keys.map((key) => nodeData[key] ?? component[key] ?? ctx[key] ?? null)) ?? "";
  }

  // src/utils/resolve-executable.ts
  function resolveExecutable(component, nodeData, { match, executable }, newValue) {
    let res = evaluateStringInComponentContext(executable, component, nodeData);
    if (res && typeof res === "object") {
      try {
        res = JSON.stringify(res);
      } catch (e) {
      }
    }
    return newValue.replace(match, res);
  }

  // src/utils/get-component-node-event-listener.ts
  function getComponentNodeEventListener(component, name, value, props = [], values = []) {
    value = value.trim();
    const match = value.match(/^(?:((?:this\.)?([a-z$_][a-z0-9$_]*)\s*\((.*)\))|\{(.*)\})$/i);
    if (match) {
      let [_, fn, fnName, fnArgs, executable] = match;
      if (executable) {
        const fn2 = new Function("$event", ...props, `"use strict";
 return ${executable};`);
        return (event) => fn2.call(component, event, ...values);
      } else {
        fn = fn.replace(/^this\./, "");
        const func = new Function("$event", ...props, `"use strict";
 return this.${fn}`);
        if (typeof component[fnName] === "function") {
          return (event) => func.call(component, event, ...values);
        }
      }
    }
    return null;
  }

  // src/utils/get-event-handler-function.ts
  function getEventHandlerFunction(component, nodeData, attribute) {
    const props = Array.from(/* @__PURE__ */ new Set([...Object.getOwnPropertyNames(nodeData), ...component.$properties]));
    const values = props.map((k) => {
      return nodeData[k] ?? component[k] ?? null;
    });
    const fn = getComponentNodeEventListener(component, attribute.name, attribute.value, props, values);
    if (fn) {
      return fn;
    } else {
      component.onError(new Error(`${component.constructor.name}: Invalid event handler for "${attribute.name}" >>> "${attribute.value}".`));
    }
    return null;
  }

  // src/node-track.ts
  var NodeTrack = class {
    constructor(node, component) {
      this.attributes = [];
      this.directives = [];
      this.property = {
        name: "",
        value: "",
        executables: []
      };
      this.empty = false;
      this.tracks = /* @__PURE__ */ new Map();
      this.dirAnchors = /* @__PURE__ */ new WeakMap();
      this.node = node;
      this.anchor = node;
      this.component = component;
      $.get(this.node).rawNodeString = /#text|#comment/.test(node.nodeName) ? node.nodeValue : node.outerHTML;
      this._setTracks();
    }
    get $context() {
      return (this.anchor === this.node ? $.get(this.node).$context : $.get(this.anchor[0] ?? this.anchor)?.$context) || {};
    }
    updateNode() {
      let directiveNode = this.node;
      for (let directive of this.directives) {
        if (directive && directive.handler) {
          try {
            const { handler } = directive;
            let val = handler.parseValue(directive.value, directive.prop);
            extractExecutableSnippetFromString(val).forEach((exc) => {
              val = resolveExecutable(this.component, this.$context, exc, val);
            });
            const value = evaluateStringInComponentContext(val, this.component, this.$context);
            directiveNode = handler.render(value, {
              element: this.node,
              anchorNode: this.dirAnchors.get(directive) ?? null,
              rawElementOuterHTML: $.get(this.node).rawNodeString
            });
            if (directiveNode !== this.node) {
              this.dirAnchors.set(directive, directiveNode);
              break;
            }
          } catch (e) {
            this.component.onError(new Error(`"${directive.name}" on ${$.get(this.node).rawNodeString}: ${e.message}`));
          }
          this.dirAnchors.set(directive, null);
        }
      }
      if (directiveNode === this.node) {
        this.anchor = this._switchNodeAndAnchor(directiveNode);
        if (this.property?.executables.length) {
          const newValue = this.property.executables.reduce((val, exc) => {
            return resolveExecutable(this.component, this.$context, exc, val);
          }, this.property.value);
          if (newValue !== this.node[this.property.name]) {
            this.node[this.property.name] = newValue;
          }
        }
        for (let { name, propName, value, executables } of this.attributes) {
          if (executables.length) {
            let newValue = executables.reduce((val, exc) => {
              return resolveExecutable(this.component, this.$context, exc, val);
            }, value);
            if (this.node[propName] !== void 0) {
              newValue = jsonParse(newValue);
              if (newValue !== this.node[propName]) {
                this.node[propName] = newValue;
              }
            } else if (this.node.getAttribute(name) !== newValue) {
              this.node.setAttribute(name, newValue);
            }
          }
        }
        this.tracks.forEach((track) => {
          track.updateNode();
        });
      } else {
        this.anchor = this._switchNodeAndAnchor(directiveNode);
      }
      return directiveNode;
    }
    _setTracks() {
      const { nodeName, nodeValue, textContent, attributes } = this.node;
      const eventHandlers = [];
      if (nodeName === "#text") {
        this.property = {
          name: "nodeValue",
          value: nodeValue || "",
          executables: []
        };
      } else {
        const attrs = [];
        const isRepeatedNode = this.node?.hasAttribute("repeat");
        if (nodeName === "TEXTAREA") {
          this.property = {
            name: "value",
            value: textContent || "",
            executables: []
          };
          this.node.textContent = "";
        } else if (nodeName === "STYLE") {
          const selectorPattern = /[a-z:#\.*\[][^{}]*[^\s:]\s*(?={){/gmi;
          const propValueStylePattern = /[a-z][a-z-]*:([^;]*)(;|})/gmi;
          let styleText = textContent ?? "";
          let match = null;
          let executables = [];
          while ((match = selectorPattern.exec(styleText)) !== null) {
            let propValueMatch = null;
            let propValue = styleText.slice(selectorPattern.lastIndex);
            while ((propValueMatch = propValueStylePattern.exec(propValue)) !== null) {
              executables.push(...extractExecutableSnippetFromString(propValueMatch[1], ["[", "]"]));
            }
          }
          if (executables.length) {
            this.property = {
              name: "textContent",
              value: styleText,
              executables
            };
          }
        }
        for (let attribute of [...attributes]) {
          if (/^(attr\.|ref|if|repeat)/.test(attribute.name)) {
            const directive = parseNodeDirective(this.node, attribute.name, attribute.value);
            if (directiveRegistry[directive.name]) {
              const Dir = directiveRegistry[directive.name];
              directive.handler = new Dir(this.component);
            }
            switch (directive.name) {
              case "if":
                this.directives.unshift(directive);
                break;
              case "repeat":
                if (this.directives[0]?.name === "if") {
                  this.directives.splice(1, 0, directive);
                } else {
                  this.directives.unshift(directive);
                }
                break;
              default:
                this.directives.push(directive);
            }
            this.node.removeAttribute(attribute.name);
          } else if (attribute.name.startsWith("on")) {
            eventHandlers.push({
              eventName: attribute.name.slice(2).toLowerCase(),
              attribute
            });
          } else {
            attrs.push(attribute);
          }
        }
        eventHandlers.forEach(({ eventName, fn, attribute }) => {
          this.node.removeAttribute(attribute.name);
          if (!fn && !isRepeatedNode) {
            fn = getEventHandlerFunction(this.component, this.$context, attribute);
            if (fn) {
              this.node.addEventListener(eventName, fn);
            }
          }
        });
        for (let attr of attrs) {
          if (attr.value.trim()) {
            this.attributes.push({
              name: attr.name,
              propName: turnKebabToCamelCasing(attr.name),
              value: attr.value,
              executables: extractExecutableSnippetFromString(attr.value)
            });
          }
        }
      }
      if (this.property?.value.trim() && !this.property.executables.length) {
        this.property.executables = extractExecutableSnippetFromString(this.property.value);
      }
      this.empty = !this.directives.length && !this.attributes.some((attr) => attr.executables.length) && !this.property.executables.length;
    }
    _createDefaultAnchor() {
      return document.createComment(` ${this.node.nodeValue ?? this.node.outerHTML} `);
    }
    _switchNodeAndAnchor(dirNode) {
      if (dirNode === this.anchor) {
        return dirNode;
      }
      let dirIsArray = Array.isArray(dirNode);
      if (dirIsArray && !dirNode.length || !dirIsArray && !/[831]/.test(`${dirNode.nodeType}`)) {
        dirNode = this._createDefaultAnchor();
        dirIsArray = false;
      }
      const anchorIsArray = Array.isArray(this.anchor);
      const anchorEl = document.createComment("bfs");
      let nextEl = anchorEl;
      if (anchorIsArray) {
        this.anchor[0]?.parentNode?.insertBefore(nextEl, this.anchor[0]);
      } else {
        this.anchor.before(nextEl);
      }
      if (dirIsArray) {
        for (let el of dirNode) {
          if (!el.isConnected) {
            nextEl.after(el);
            this._trackNode(el);
            $.get(el).shadowNode = this.node;
          }
          nextEl = el;
        }
      } else {
        nextEl.after(dirNode);
        if (!$.has(dirNode)) {
          this._trackNode(dirNode);
        }
      }
      if (anchorIsArray) {
        for (let el of this.anchor) {
          if (!dirIsArray || !dirNode.includes(el)) {
            el.parentNode?.removeChild(el);
            this._unTrackNode(el);
          }
        }
      } else if (this.anchor !== dirNode) {
        this.anchor.parentNode?.removeChild(this.anchor);
        this._unTrackNode(this.anchor);
      }
      anchorEl.parentNode?.removeChild(anchorEl);
      this.anchor = dirNode;
      return dirNode;
    }
    _trackNode(n) {
      trackNode(n, this.component, {
        tracks: this.tracks
      });
    }
    _unTrackNode(n) {
      if (n !== this.node) {
        this.tracks.delete(n);
        n.childNodes.forEach((c) => this._unTrackNode(c));
      }
    }
  };

  // src/tags/slot.tag.ts
  var slotTag = (node, { component } = {}, cb) => {
    const attrs = Array.from(node.attributes);
    if (component.type === "context") {
      cb(renderCustomSlot(node, component.childNodes, attrs));
    } else {
      renderSlot(node, attrs, cb);
    }
  };
  function renderSlot(node, attrs, cb) {
    const onSlotChange = () => {
      const nodes = node.assignedNodes();
      nodes.forEach((n) => {
        if (n.nodeType === 1) {
          attrs.forEach(({ name, value }) => name !== "name" && n.setAttribute(name, value));
        }
      });
      cb(nodes);
      node.removeEventListener("slotchange", onSlotChange, false);
    };
    node.addEventListener("slotchange", onSlotChange, false);
    cb(Array.from(node.childNodes));
  }
  function renderCustomSlot(node, childNodes, attrs) {
    const name = node.getAttribute("name");
    let nodeList;
    let comment = document.createComment(`slotted [${name || ""}]`);
    node.parentNode?.replaceChild(comment, node);
    if (name) {
      nodeList = childNodes.filter((n) => {
        return n.nodeType === 1 && n.getAttribute("slot") === name;
      });
    } else {
      nodeList = childNodes.filter((n) => {
        return n.nodeType !== 1 || !n.hasAttribute("slot");
      });
    }
    if (!nodeList.length) {
      nodeList = Array.from(node.childNodes);
    }
    let anchor = comment;
    for (let n of nodeList) {
      if (n.nodeType === 1) {
        attrs.forEach((a) => a.name !== "name" && n.setAttribute(a.name, a.value));
      }
      anchor.after(n);
      anchor = n;
    }
    comment.parentNode?.removeChild(comment);
    return nodeList;
  }

  // src/utils/track-node.ts
  function trackNode(node, component, opt) {
    const { nodeName, nodeValue, childNodes, nodeType } = node;
    if ($.get(node)?.tracked || nodeName === "#text" && !nodeValue?.trim()) {
      return;
    }
    defineNodeContextMetadata(node);
    $.get(node).tracked = true;
    if (/#comment|SCRIPT/.test(nodeName)) {
      return;
    }
    let { trackOnly = false, tracks } = opt;
    if (nodeName === "SLOT") {
      slotTag(node, {
        component: {
          type: component.customSlot ? "context" : "default",
          childNodes: component._childNodes
        }
      }, (nodes) => {
        nodes.forEach((node2) => {
          trackNode(node2, component, opt);
        });
      });
    } else {
      if (nodeType !== 11) {
        if (nodeType === 1 || nodeName === "#text") {
          const track = new NodeTrack(node, component);
          if (!track.empty) {
            $.get(node).track = track;
            tracks.set(node, track);
            if (!trackOnly) {
              const res = track.updateNode();
              if (res !== node) {
                trackOnly = true;
                if (Array.isArray(res)) {
                  return;
                }
              }
            }
            tracks = track.tracks;
          }
        }
        if (/#text|TEXTAREA|STYLE/.test(nodeName)) {
          return;
        }
      }
      Array.from(childNodes).forEach((c) => trackNode(c, component, { ...opt, trackOnly, tracks }));
    }
  }

  // src/utils/resolve-html-entities.ts
  function resolveHtmlEntities(html) {
    const e = document.createElement("textarea");
    e.innerHTML = html;
    return e.textContent || "";
  }

  // src/web-component.ts
  var WebComponent = class extends HTMLElement {
    constructor() {
      super();
      this.$refs = {};
      this.$properties = ["$context", "$refs"];
      this.templateId = "";
      this._childNodes = [];
      let { mode, observedAttributes, delegatesFocus } = this.constructor;
      if (!$.has(this)) {
        $.set(this, {});
      }
      const meta = $.get(this);
      meta.root = this;
      meta.mounted = false;
      meta.parsed = false;
      meta.clearAttr = false;
      meta.tracks = /* @__PURE__ */ new Map();
      meta.unsubscribeCtx = () => {
      };
      meta.attrPropsMap = observedAttributes.reduce((map, attr) => ({
        ...map,
        [attr]: turnKebabToCamelCasing(attr)
      }), {});
      if (mode !== "none") {
        $.get(this).root = this.attachShadow({ mode, delegatesFocus });
      }
    }
    static parseHTML(markup) {
      return parse(markup);
    }
    static register(tagName) {
      tagName = typeof tagName === "string" && tagName ? tagName : typeof this.tagName === "string" && this.tagName ? this.tagName : turnCamelToKebabCasing(this.name);
      this.tagName = tagName;
      if (!customElements.get(tagName)) {
        customElements.define(tagName, this);
      }
    }
    static registerAll(components) {
      components.forEach((comp) => comp.register());
    }
    static get isRegistered() {
      return customElements.get(this.tagName) !== void 0;
    }
    get customSlot() {
      return false;
    }
    get root() {
      return this.constructor.mode === "closed" ? null : $.get(this).root;
    }
    get mounted() {
      return $.get(this)?.mounted ?? false;
    }
    get stylesheet() {
      return "";
    }
    get template() {
      return "";
    }
    get parsed() {
      return $.get(this).parsed;
    }
    get $context() {
      return $.get(this).$context;
    }
    updateContext(ctx) {
      $.get(this).updateContext(ctx);
    }
    connectedCallback() {
      defineNodeContextMetadata(this);
      const { initialContext, observedAttributes, name } = this.constructor;
      const { parsed, tracks, root, attrPropsMap } = $.get(this);
      if (Object.keys(initialContext).length) {
        $.get(this).updateContext(initialContext);
      }
      const onPropUpdate = (prop, oldValue, newValue, update = true) => {
        if (this.mounted) {
          if (update) {
            this.forceUpdate();
          }
          this.onUpdate(prop, oldValue, newValue);
        } else if (this.parsed) {
          this.onError(new Error(`[Possibly a memory leak]: Cannot set property "${prop}" on unmounted component.`));
        }
      };
      try {
        $.get(this).unsubscribeCtx = $.get(this).subscribe((newContext) => {
          onPropUpdate("$context", $.get(this).$context, newContext, false);
        });
        $.get(this).mounted = true;
        if (parsed) {
          this.updateContext({});
        } else {
          this.$properties.push(...setComponentPropertiesFromObservedAttributes(this, observedAttributes, attrPropsMap, onPropUpdate), ...setupComponentPropertiesForAutoUpdate(this, onPropUpdate));
          Object.freeze(this.$properties);
          let contentNode;
          const hasShadowRoot = this.constructor.mode !== "none";
          const style = getStyleString(this.stylesheet, this.constructor.tagName, hasShadowRoot);
          let temp = this.template;
          if (!temp && this.templateId) {
            const t = document.getElementById(this.templateId);
            temp = t?.nodeName === "TEMPLATE" ? t.innerHTML : temp;
          }
          contentNode = parse(resolveHtmlEntities(style + temp));
          this._childNodes = Array.from(this.childNodes);
          if (this.customSlot) {
            this.innerHTML = "";
          }
          trackNode(contentNode, this, {
            tracks
          });
          const { tagName, mode } = this.constructor;
          if (mode === "none") {
            const styles = contentNode.querySelectorAll("style");
            styles.forEach((style2) => {
              const existingStyleElement = document.head.querySelector(`style.${tagName}`);
              if (existingStyleElement) {
                existingStyleElement.textContent = `${style2?.textContent}${existingStyleElement.textContent}`;
              } else {
                document.head.appendChild(style2);
              }
            });
          }
          $.get(this).parsed = true;
          root.appendChild(contentNode);
        }
        this.onMount();
      } catch (e) {
        this.onError(e);
      }
    }
    onMount() {
    }
    disconnectedCallback() {
      try {
        $.get(this).mounted = false;
        $.get(this).unsubscribeCtx();
        this.onDestroy();
      } catch (e) {
        this.onError(e);
      }
    }
    onDestroy() {
    }
    attributeChangedCallback(name, oldValue, newValue) {
      if (newValue === null && !this.hasAttribute(name) && $.get(this).clearAttr) {
        $.get(this).clearAttr = false;
      } else if (this.mounted) {
        try {
          if (!(name.startsWith("data-") || name === "class" || name === "style")) {
            const prop = $.get(this).attrPropsMap[name];
            this[prop] = boolean_attributes_default.hasOwnProperty(prop) ? this.hasAttribute(name) : jsonParse(newValue);
          } else {
            this.forceUpdate();
            this.onUpdate(name, oldValue, newValue);
          }
        } catch (e) {
          this.onError(e);
        }
      }
    }
    onUpdate(name, oldValue, newValue) {
    }
    forceUpdate() {
      if (this.mounted) {
        cancelAnimationFrame($.get(this).updateFrame);
        $.get(this).updateFrame = requestAnimationFrame(() => {
          $.get(this).tracks.forEach((t) => {
            t.updateNode();
          });
        });
        return true;
      }
      return false;
    }
    adoptedCallback() {
      try {
        this.onAdoption();
      } catch (e) {
        this.onError(e);
      }
    }
    onAdoption() {
    }
    onError(error) {
      console.error(this.constructor.name, error);
    }
  };
  WebComponent.observedAttributes = [];
  WebComponent.mode = "open" /* OPEN */;
  WebComponent.delegatesFocus = false;
  WebComponent.tagName = "";
  WebComponent.initialContext = {};

  // src/context-provider-component.ts
  var ContextProviderComponent = class extends WebComponent {
    get customSlot() {
      return true;
    }
    get template() {
      return "<slot></slot>";
    }
    get stylesheet() {
      return ":host { display: block; }";
    }
  };
  ContextProviderComponent.mode = "none" /* NONE */;

  // src/client.ts
  if (window) {
    window.WebComponent = WebComponent;
    window.ContextProviderComponent = ContextProviderComponent;
    window.Directive = Directive;
  }
})();
