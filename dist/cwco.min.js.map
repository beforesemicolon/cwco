{
  "version": 3,
  "sources": ["../src/directives/registry.ts", "../src/core/$.ts", "../src/tracker/utils/define-node-context-metadata.ts", "../src/core/directive.ts", "../src/directives/if.directive.ts", "../src/directives/ref.directive.ts", "../src/utils/turn-kebab-to-camel-casing.ts", "../src/utils/turn-camel-to-kebab-casing.ts", "../src/directives/attr.directive.ts", "../src/parser/parse.ts", "../src/directives/repeat.directive.ts", "../src/directives/bind.directive.ts", "../src/directives/index.ts", "../src/utils/is-primitive.ts", "../src/utils/proxify.ts", "../src/utils/json-parse.ts", "../src/core/utils/set-component-properties-from-observed-attributes.ts", "../src/core/utils/setup-component-properties-for-auto-update.ts", "../src/core/utils/get-style-string.ts", "../src/utils/resolve-html-entities.ts", "../src/tracker/utils/evaluate-string-in-component-context.ts", "../src/utils/json-stringify.ts", "../src/tracker/utils/resolve-executables.ts", "../src/tracker/utils/extract-executable-snippet-from-string.ts", "../src/tags/slot.tag.ts", "../src/tracker/utils/extract-executable-snippet-from-css.ts", "../src/tracker/utils/parse-node-directive.ts", "../src/tracker/utils/get-event-handler-function.ts", "../src/tracker/track.ts", "../src/tracker/track-node.ts", "../src/tracker/track-node-tree.ts", "../src/tracker/node-track.ts", "../src/core/utils/json-to-css.ts", "../src/core/web-component.ts", "../src/core/context-provider-component.ts", "../src/utils/html.ts", "../src/client.ts"],
  "sourcesContent": ["import {CWCO} from \"../cwco\";\n\nexport const directiveRegistry: {[key: string]: CWCO.DirectiveConstructor} = {};\n", "/**\n * metadata is a simple global object that is used to store data related to the node\n * to prevent attaching properties on the node directly also to prevent this data\n * to be manipulated when user has reference of the node object.\n *\n * its weak nature also means that when no node reference exists, these data will simply be\n * garbage collected\n */\nexport const $: WeakMap<any, any> = new WeakMap();\n", "import {CWCO} from \"../../cwco\";\nimport {$} from \"../../core/$\";\n\nexport function defineNodeContextMetadata(node: Node) {\n\tif ($.has(node) && $.get(node)?.$context) {\n\t\treturn;\n\t}\n\n\tlet ctx: CWCO.ObjectLiteral = {};\n\tconst dt: CWCO.ObjectLiteral = $.get(node) || {};\n\n\tdt.updateContext = (newCtx: CWCO.ObjectLiteral | null = null) => {\n\t\tconst oldCtx = ctx;\n\n\t\tif (newCtx && typeof newCtx === 'object' && Object.keys(newCtx).length) {\n\t\t\tctx = {...ctx, ...newCtx};\n\t\t}\n\n\t\treturn {oldCtx, newCtx: ctx};\n\t}\n\n\tObject.defineProperty(dt, '$context', {\n\t\tget() {\n\t\t\treturn {...$.get(getParent(node))?.$context, ...ctx};\n\t\t}\n\t})\n\n\t$.set(node, dt);\n}\n\nfunction getParent(node: Node) {\n\treturn node.parentNode instanceof ShadowRoot\n\t\t? node.parentNode.host\n\t\t: node.parentNode\n}\n\n", "import {directiveRegistry} from \"../directives/registry\";\nimport {$} from \"./$\";\nimport {defineNodeContextMetadata} from \"../tracker/utils/define-node-context-metadata\";\nimport {CWCO} from \"../cwco\";\n\nexport class Directive implements CWCO.Directive  {\n\tconstructor(component: CWCO.WebComponent) {\n\t\t$.set(this, {component})\n\t}\n\n\tstatic register(name: string = '') {\n\t\tname = (name || this.name).toLowerCase();\n\n\t\tif (!directiveRegistry.hasOwnProperty(name)) {\n\t\t\tdirectiveRegistry[name] = this;\n\t\t}\n\t}\n\n\tparseValue(value: string, prop: string | null) {\n\t\treturn value;\n\t}\n\n\trender(val: unknown, {element}: CWCO.directiveRenderOptions): CWCO.directiveRenderOptions['anchorNode'] {\n\t\treturn element;\n\t}\n\n\tsetRef(name: string, node: Node) {\n\t\tconst currRef = $.get(this).component.$refs[name];\n\n\t\tif (currRef === undefined) {\n\t\t\t$.get(this).component.$refs[name] = node;\n\t\t} else if(Array.isArray(currRef)) {\n\t\t\t!currRef.includes(node) && currRef.push(node);\n\t\t} else if(currRef !== node) {\n\t\t\t$.get(this).component.$refs[name] = [currRef, node];\n\t\t}\n\t}\n\n\tgetContext(node: Node) {\n\t\treturn $.get(node).$context ?? null;\n\t}\n\n\tupdateContext(node: Node, newCtx: CWCO.ObjectLiteral) {\n\t\tdefineNodeContextMetadata(node);\n\t\t$.get(node)?.updateContext(newCtx);\n\t}\n}\n", "import {Directive} from \"../core/directive\";\nimport {CWCO} from \"../cwco\";\n\nexport class If extends Directive {\n\trender(condition: boolean, {element, anchorNode}: CWCO.directiveRenderOptions) {\n\t\treturn condition\n\t\t\t? element\n\t\t\t: (anchorNode || new Comment(` if: ${condition} `));\n\t}\n}\n\n", "import {Directive} from \"../core/directive\";\nimport {CWCO} from \"../cwco\";\n\nexport class Ref extends Directive {\n\tparseValue(value: string): string {\n\t\treturn `\"${value}\"`;\n\t}\n\n\trender(name: string, {element}: CWCO.directiveRenderOptions) {\n\t\tif (/^[a-z$_][a-z0-9$_]*$/i.test(name)) {\n\t\t\tthis.setRef(name, element);\n\t\t\treturn element;\n\t\t}\n\n\t\tthrow new Error(`Invalid \"ref\" property name \"${name}\"`)\n\t}\n}\n\n", "export function turnKebabToCamelCasing(name: string): string {\n\treturn name\n\t\t.split(/-+/)\n\t\t.map((part, i) => i === 0 && part.length > 1 ? part : part[0].toUpperCase() + part.slice(1))\n\t\t.join('') ?? name;\n}", "export function turnCamelToKebabCasing(name: string): string {\n\treturn name\n\t\t.match(/(?:[A-Z]+(?=[A-Z][a-z])|[A-Z]+|[a-zA-Z])[a-z]*/g)\n\t\t?.map(p => p.toLowerCase())\n\t\t.join('-') ?? name;\n}\n", "import {Directive} from \"../core/directive\";\nimport {turnKebabToCamelCasing} from \"../utils/turn-kebab-to-camel-casing\";\nimport {turnCamelToKebabCasing} from \"../utils/turn-camel-to-kebab-casing\";\nimport booleanAttr from \"../core/boolean-attributes.json\";\nimport {CWCO} from \"../cwco\";\n\nexport class Attr extends Directive {\n\tparseValue(value: string, prop: string | null): string {\n\t\tlet [attrName, property = null] = (prop ?? '').split('.');\n\t\tconst commaIdx = value.lastIndexOf(',');\n\n\t\treturn `[\"${attrName}\", \"${property || ''}\", ${commaIdx >= 0 ? value.slice(commaIdx + 1).trim() : value}, \"${commaIdx >= 0 ? value.slice(0, commaIdx).trim() : ''}\"]`;\n\t}\n\n\trender([attrName, property, shouldAdd, val]: any, {element}: CWCO.directiveRenderOptions): HTMLElement {\n\t\tswitch (attrName) {\n\t\t\tcase 'style':\n\t\t\t\tif (property) {\n\t\t\t\t\tproperty = turnKebabToCamelCasing(property);\n\n\t\t\t\t\telement.style[property] = shouldAdd ? val : '';\n\t\t\t\t} else {\n\t\t\t\t\tval\n\t\t\t\t\t\t.match(/([a-z][a-z-]+)(?=:):([^;]+)/g)\n\t\t\t\t\t\t?.forEach((style: string) => {\n\t\t\t\t\t\t\tlet [name, styleValue] = style.split(':').map(s => s.trim());\n\n\t\t\t\t\t\t\tif (shouldAdd) {\n\t\t\t\t\t\t\t\telement.style.setProperty(name, styleValue);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\telement.setAttribute(\n\t\t\t\t\t\t\t\t\t'style',\n\t\t\t\t\t\t\t\t\telement.style.cssText.replace(new RegExp(`${name}\\\\s*:\\\\s*${styleValue};?`, 'g'), ''))\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 'class':\n\t\t\t\tif (property) {\n\t\t\t\t\tif (shouldAdd) {\n\t\t\t\t\t\telement.classList.add(property);\n\t\t\t\t\t} else {\n\t\t\t\t\t\telement.classList.remove(property);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst classes = val.split(/\\s+/g);\n\n\t\t\t\t\tif (shouldAdd) {\n\t\t\t\t\t\tclasses.forEach((cls: string) => element.classList.add(cls));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclasses.forEach((cls: string) => element.classList.remove(cls));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'data':\n\t\t\t\tif (property) {\n\t\t\t\t\tif (shouldAdd) {\n\t\t\t\t\t\telement.dataset[turnKebabToCamelCasing(property)] = val;\n\t\t\t\t\t} else {\n\t\t\t\t\t\telement.removeAttribute(`data-${turnCamelToKebabCasing(property)}`)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (attrName) {\n\t\t\t\t\tif (shouldAdd) {\n\t\t\t\t\t\telement.setAttribute(attrName,\n\t\t\t\t\t\t\tbooleanAttr.hasOwnProperty(attrName) ? '' : `${val || shouldAdd}`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\telement.removeAttribute(attrName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t\treturn element;\n\t}\n}\n", "import selfClosingTags from './self-closing-tags.json';\nimport {CWCO} from \"../cwco\";\n\nconst NSURI: CWCO.ObjectLiteral = {\n\tHTML: 'http://www.w3.org/1999/xhtml',\n\tSVG: 'http://www.w3.org/2000/svg',\n}\n\nexport function parse(markup: string) {\n\tconst tagCommentPattern = /<!--([^]*?)-->|<(\\/|!)?([a-z][\\w-.:]*)((?:\\s*[a-z][\\w-.:]*(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'))?)+\\s*|\\s*)(\\/?)>/ig;\n\tconst root = document.createDocumentFragment();\n\tconst stack: Array<DocumentFragment | HTMLElement | Element> = [root];\n\tlet match: RegExpExecArray | null = null;\n\tlet lastIndex = 0;\n\tlet isNSTag = false\n\tlet URI = ''\n\n\twhile ((match = tagCommentPattern.exec(markup)) !== null) {\n\t\tlet [fullMatch, comment, closeOrBangSymbol, tagName, attributes, selfCloseSlash] = match;\n\n\t\ttagName = tagName?.toUpperCase();\n\n\t\tif (closeOrBangSymbol === '!') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst parentNode = stack[stack.length - 1] || null;\n\n\t\t// grab in between text\n\t\tif (lastIndex !== match.index) {\n\t\t\tconst textNode = document.createTextNode(markup.slice(lastIndex, match.index));\n\t\t\tparentNode.appendChild(textNode);\n\t\t}\n\n\t\tlastIndex = tagCommentPattern.lastIndex;\n\n\t\tif (comment) {\n\t\t\tconst commentNode = document.createComment(comment);\n\t\t\tparentNode.appendChild(commentNode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tisNSTag = isNSTag || /SVG|HTML/i.test(tagName);\n\n\t\tif (/SVG|HTML/i.test(tagName)) {\n\t\t\tURI = NSURI[tagName.toUpperCase()];\n\t\t}\n\n\t\tif (selfCloseSlash || (selfClosingTags as {[key: string]: string})[tagName]) {\n\t\t\tconst node = isNSTag\n\t\t\t\t? document.createElementNS(URI, tagName.toLowerCase())\n\t\t\t\t: document.createElement(tagName);\n\n\t\t\tsetAttributes(node, attributes)\n\n\t\t\tparentNode.appendChild(node);\n\t\t} else if (closeOrBangSymbol === '/') {\n\t\t\tisNSTag = /SVG|HTML/i.test(tagName) ? false : isNSTag;\n\t\t\tURI = /SVG|HTML/i.test(tagName) ? '' : URI;\n\t\t\tstack.pop();\n\t\t} else if (!closeOrBangSymbol) {\n\t\t\tconst node = isNSTag\n\t\t\t\t? document.createElementNS(URI, tagName.toLowerCase())\n\t\t\t\t: document.createElement(tagName);\n\n\t\t\tsetAttributes(node, attributes)\n\n\t\t\tparentNode.appendChild(node);\n\n\t\t\tstack.push(node)\n\t\t}\n\t}\n\n\t// grab ending text\n\tif (lastIndex < markup.length) {\n\t\tconst textNode = document.createTextNode(markup.slice(lastIndex));\n\t\troot.appendChild(textNode);\n\t}\n\n\treturn root;\n}\n\nfunction setAttributes(node: Element | HTMLElement, attributes: string) {\n\tconst attrPattern = /([a-z][\\w-.:]*)(?:\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|(\\S+)))?/ig;\n\tlet match: RegExpExecArray | null = null;\n\n\twhile ((match = attrPattern.exec(attributes))) {\n\t\tlet name = match[1];\n\t\tconst value = match[2] || match[3] || match[4] || (\n\t\t\tnew RegExp(`^${match[1]}\\\\s*=`).test(match[0]) ? '' : null\n\t\t)\n\n\t\tnode.setAttribute(name, value ?? '');\n\t}\n}\n", "import {Directive} from \"../core/directive\";\nimport {parse} from \"../parser/parse\";\nimport {CWCO} from \"../cwco\";\n\nexport class Repeat extends Directive {\n\tparseValue(value: string): string {\n\t\tconst idx = value.lastIndexOf(';');\n\t\tlet iPart = value;\n\t\tlet kPart = '';\n\t\t\n\t\tif (idx > 0) {\n\t\t\tiPart = value.slice(0, idx);\n\t\t\tkPart = value.slice(idx + 1);\n\t\t}\n\t\t\n\t\tconst [v, vAs = \"$item\"] = `${iPart} `.split(/\\s+as\\s+/g).map(s => s.trim());\n\t\tconst [k, kAs = \"$key\"] = `${kPart} `.split(/\\s+as\\s+/g).map(s => s.trim());\n\t\t\n\t\treturn `[${v}, \"${vAs}\", \"${k === '$key' ? kAs : ''}\"]`;\n\t}\n\t\n\trender([repeatData, vAs, kAs]: any, {element, rawElementOuterHTML, anchorNode}: CWCO.directiveRenderOptions) {\n\t\tanchorNode = (anchorNode ?? []) as Array<Element>;\n\t\tconst list: Array<Element> = [];\n\n\t\tif (element.nodeType === 1) {\n\t\t\tlet times: number;\n\n\t\t\tif (Number.isInteger(repeatData)) {\n\t\t\t\ttimes = repeatData;\n\t\t\t} else {\n\t\t\t\trepeatData = repeatData instanceof Set ? Object.entries(Array.from(repeatData))\n\t\t\t\t\t: repeatData instanceof Map ? Array.from(repeatData.entries())\n\t\t\t\t\t\t: repeatData[Symbol.iterator] ? Object.entries([...repeatData])\n\t\t\t\t\t\t\t: Object.entries(repeatData);\n\t\t\t\ttimes = repeatData.length;\n\t\t\t}\n\n\t\t\tfor (let index = 0; index < times; index++) {\n\t\t\t\tif (anchorNode[index]) {\n\t\t\t\t\tthis.updateNodeContext(anchorNode[index], index, vAs, kAs, repeatData);\n\t\t\t\t\tlist.push(anchorNode[index]);\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tconst el = parse(rawElementOuterHTML).children[0];\n\t\t\t\tthis.updateNodeContext(el, index, vAs, kAs, repeatData)\n\t\t\t\tlist.push(el);\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t}\n\t\n\tupdateNodeContext(el: Node, index: number, vAs: string, kAs: string, list: Array<any> = []) {\n\t\tconst [key, value] = list[index] ?? [index, index + 1];\n\t\t// set context so this and inner nodes can catch these values\n\t\tthis.updateContext(el, {\n\t\t\t[vAs || '$item']: value,\n            [kAs || '$key']: key\n\t\t});\n\t}\n}\n\n", "import {Directive} from \"../core/directive\";\nimport {CWCO} from \"../cwco\";\n\nexport class Bind extends Directive {\n\tparseValue(value: string, prop: string | null) {\n\t\treturn `[\"${(prop || '').trim()}\", \"${value}\"]`;\n\t}\n\n\trender([prop, value]: [string, any], {element, anchorNode}: CWCO.directiveRenderOptions) {\n\t\tif (prop) {\n\t\t\t(element as CWCO.ObjectLiteral)[prop] = value;\n\t\t} else {\n\t\t\telement.textContent = value;\n\t\t}\n\n\t\treturn element;\n\t}\n}\n\n", "import {If} from './if.directive';\nimport {Ref} from './ref.directive';\nimport {Attr} from './attr.directive';\nimport {Repeat} from './repeat.directive';\nimport {Bind} from \"./bind.directive\";\n\nIf.register();\nRef.register();\nAttr.register();\nRepeat.register();\nBind.register();\n\nexport const directives = new Set([\n\tIf.name.toLowerCase(),\n\tRef.name.toLowerCase(),\n\tAttr.name.toLowerCase(),\n\tRepeat.name.toLowerCase(),\n\tBind.name.toLowerCase(),\n])\n", "export const isPrimitive = (val: any) => {\n\treturn /number|string|bigint|boolean|symbol/.test(typeof val)\n}", "import {isPrimitive} from \"./is-primitive\";\n\nconst TypedArray = Object.getPrototypeOf(Uint8Array);\n\nexport function proxify(name: string, object: any, notify: (name: string, o: any) => void = () => {\n}, self = null): any {\n\tself = self ?? object;\n\t\n\tif (\n\t\t!object ||\n\t\tobject.__isProxy || // ignore objects already gone through proxify\n\t\tisPrimitive(object) || // ignore primitives\n\t\ttypeof object === 'function' || // ignore functions\n\t\t(\n\t\t\t// ignore any object that is not in this array or an object literal\n\t\t\t![Array, Map, Set, TypedArray].some(o => object instanceof o) &&\n\t\t\t(object.constructor && object.constructor.name !== 'Object')\n\t\t)\n\t) {\n\t\treturn object;\n\t}\n\n\treturn new Proxy(object, {\n\t\tget(obj, n: string) {\n\t\t\tif (n === \"__isProxy\") {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tlet res = Reflect.get(obj, n);\n\n\t\t\tif (res) {\n\t\t\t\tif (typeof res === 'object') {\n\t\t\t\t\treturn proxify(name, res, notify, self);\n\t\t\t\t}\n\n\t\t\t\tif (typeof res === 'function') {\n\t\t\t\t\tif (typeof n !== 'symbol') {\n\t\t\t\t\t\t// for each can be used to loop over the properties of an object\n\t\t\t\t\t\t// to change the value of each property which is the reason to proxify the items\n\t\t\t\t\t\t// but the same cannot be said to methods like map, reduce and filter\n\t\t\t\t\t\t// which return a new object and not the original one so for those\n\t\t\t\t\t\t// to have the change event triggered, the return objects must be used to replace the object\n\t\t\t\t\t\t// and get proxified in the process\n\t\t\t\t\t\tif (/forEach/.test(n)) {\n\t\t\t\t\t\t\treturn (cb: (v: any, k: number, l: any) => void, thisArg?: any) => {\n\t\t\t\t\t\t\t\tobj[n]((v: any, k: number, l: any) => {\n\t\t\t\t\t\t\t\t\tcb.call(thisArg ?? obj, proxify(name, v, notify, self), k, l);\n\t\t\t\t\t\t\t\t}, thisArg ?? obj);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else if (/values|entries|keys/.test(n)) {\n\t\t\t\t\t\t\t// keys need to also be proxified becuase they may be objects which are used in the\n\t\t\t\t\t\t\t// template for rendering\n\t\t\t\t\t\t\treturn () => ({\n\t\t\t\t\t\t\t\t*[Symbol.iterator]() {\n\t\t\t\t\t\t\t\t\tif (n === 'entries') {\n\t\t\t\t\t\t\t\t\t\tfor (const [k, v] of obj[n]()) {\n\t\t\t\t\t\t\t\t\t\t\tyield [proxify(name, k, notify, self), proxify(name, v, notify, self)];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tfor (const v of obj[n]()) {\n\t\t\t\t\t\t\t\t\t\t\tyield proxify(name, v, notify, self);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn (...args: any[]) => {\n\t\t\t\t\t\t\tconst r = res.apply(obj, args);\n\n\t\t\t\t\t\t\t// reading any item while it is still in the object should be proxified\n\t\t\t\t\t\t\t// to allow for detecting changes\n\t\t\t\t\t\t\tif (typeof r === 'object' && (\n\t\t\t\t\t\t\t\t(Array.isArray(obj) && /at|find/.test(n)) ||\n\t\t\t\t\t\t\t\t((obj instanceof Map) && /get/.test(n)) ||\n\t\t\t\t\t\t\t\t((obj instanceof WeakMap) && /get/.test(n))\n\t\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\t\treturn proxify(name, r, notify, self);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// this is done under the assumption that the function\n\t\t\t\t\t\t\t// will always update the object\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t(Array.isArray(obj) && /push|pop|splice|shift|unshift|reverse|sort|fill|copyWithin/.test(n)) ||\n\t\t\t\t\t\t\t\t((obj instanceof Map) && /set|delete|clear/.test(n)) ||\n\t\t\t\t\t\t\t\t((obj instanceof Set) && /add|delete|clear/.test(n)) ||\n\t\t\t\t\t\t\t\t((obj instanceof WeakSet) && /add|delete/.test(n)) ||\n\t\t\t\t\t\t\t\t((obj instanceof WeakMap) && /set|delete/.test(n))\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tnotify(name, self);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn r;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// make sure the object it bound to the function for when it is called\n\t\t\t\t\t\tres = res.bind(obj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn res;\n\t\t},\n\t\tset(obj, n: string, value) {\n\t\t\tconst res = Reflect.set(obj, n, value);\n\n\t\t\tnotify(name, self);\n\n\t\t\treturn res;\n\t\t},\n\t\tdeleteProperty(target: any, p: string | symbol): boolean {\n            const res = Reflect.deleteProperty(target, p);\n\n            notify(name, self);\n\n            return res;\n        },\n\t\tdefineProperty(target: any, p: string | symbol, attributes: PropertyDescriptor): boolean {\n            const res = Reflect.defineProperty(target, p, attributes);\n\n            notify(name, self);\n\n            return res;\n        },\n\t});\n}\n", "export function jsonParse(value: string): any {\n\tif (value && typeof value === 'string') {\n\t\ttry {\n\t\t\tvalue = JSON.parse(value.replace(/['`]/g, '\"'));\n\t\t} catch (e) {\n\t\t}\n\t}\n\n\treturn value;\n}", "import {proxify} from '../../utils/proxify';\nimport boolAttr from '../boolean-attributes.json';\nimport {directives} from \"../../directives\";\nimport {jsonParse} from \"../../utils/json-parse\";\nimport {$} from \"../$\";\nimport {CWCO} from \"../../cwco\";\nimport {isPrimitive} from \"../../utils/is-primitive\";\n\nexport function setComponentPropertiesFromObservedAttributes(\n\tcomp: CWCO.WebComponent,\n\tattrs: string[],\n\tattrsMap: CWCO.ObjectLiteral = {},\n\tcb: CWCO.onUpdateCallback\n): string[] {\n\tconst properties: string[] = [];\n\n\tattrs.forEach(attr => {\n\t\tattr = attr.trim();\n\n\t\tif (!directives.has(attr) && !(attr.startsWith('data-') || attr === 'class' || attr === 'style')) {\n\t\t\tlet prop = attrsMap[attr];\n\t\t\tlet value: any = (comp.getAttribute(attr) ?? comp[prop]) ?? '';\n\n\t\t\tproperties.push(prop);\n\n\t\t\tif (typeof value === 'string') {\n\t\t\t\tvalue = proxify(prop, jsonParse(value), (name, val) => {\n\t\t\t\t\tcb(name, val, val);\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\tif ((boolAttr).hasOwnProperty(prop)) {\n\t\t\t\tvalue = comp.hasAttribute(attr);\n\t\t\t\tprop = (boolAttr as CWCO.booleanAttributes)[prop].name;\n\t\t\t}\n\n\t\t\tObject.defineProperty(comp, prop, {\n\t\t\t\tget() {\n\t\t\t\t\treturn value;\n\t\t\t\t},\n\t\t\t\tset(newValue) {\n\t\t\t\t\tconst oldValue = value;\n\n\t\t\t\t\tif (!isPrimitive(newValue)) {\n\t\t\t\t\t\tif (comp.hasAttribute(attr)) {\n\t\t\t\t\t\t\t$.get(comp).clearAttr = true;\n\t\t\t\t\t\t\tcomp.removeAttribute(attr);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvalue = proxify(prop, newValue, () => {\n\t\t\t\t\t\t\tcb(prop, oldValue, newValue);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tcb(prop, oldValue, value);\n\t\t\t\t\t} else if(oldValue !== newValue) {\n\t\t\t\t\t\tvalue = newValue;\n\t\t\t\t\t\tcb(prop, oldValue, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n\n\treturn properties;\n}\n", "import {turnCamelToKebabCasing} from \"../../utils/turn-camel-to-kebab-casing\";\nimport {directives} from \"../../directives\";\nimport {proxify} from \"../../utils/proxify\";\nimport {CWCO} from \"../../cwco\";\nimport {isPrimitive} from \"../../utils/is-primitive\";\n\nexport function setupComponentPropertiesForAutoUpdate(comp: CWCO.WebComponent, onUpdate: CWCO.onUpdateCallback): string[] {\n\tconst properties: string[] = [];\n\n\tfor (let prop of Object.getOwnPropertyNames(comp)) {\n\t\t// should not watch function properties\n\t\tif (typeof comp[prop] === 'function') {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tconst attr = turnCamelToKebabCasing(prop);\n\n\t\t// ignore private properties and $ properties as well as attribute properties\n\t\tif (!directives.has(prop) && !/\\$|_/.test(prop[0]) && !(comp.constructor as CWCO.WebComponentConstructor).observedAttributes.includes(attr)) {\n\t\t\t// @ts-ignore\n\t\t\tlet value = comp[prop];\n\t\t\t\n\t\t\tproperties.push(prop);\n\n\t\t\tvalue = proxify(prop, value, () => {\n\t\t\t\tonUpdate(prop, value, value);\n\t\t\t})\n\n\t\t\tObject.defineProperty(comp, prop, {\n\t\t\t\tget() {\n\t\t\t\t\treturn value;\n\t\t\t\t},\n\t\t\t\tset(newValue) {\n\t\t\t\t\tconst oldValue = value;\n\n\t\t\t\t\tif (!isPrimitive(newValue)) {\n\t\t\t\t\t\tvalue = proxify(prop, newValue, () => {\n\t\t\t\t\t\t\tonUpdate(prop, oldValue, newValue);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tonUpdate(prop, oldValue, value);\n\t\t\t\t\t} else if(oldValue !== newValue) {\n\t\t\t\t\t\tvalue = newValue;\n\t\t\t\t\t\tonUpdate(prop, oldValue, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\treturn properties;\n}\n", "export function getStyleString(stylesheet: string, tagName: string, hasShadowRoot: boolean = true) {\n\tstylesheet = stylesheet.trim().replace(/\\s{2,}/g, ' ');\n\n\tif (!stylesheet) {\n\t    return '';\n\t}\n\n\tconst div = document.createElement('div');\n\n\tdiv.innerHTML = stylesheet;\n\tconst styleTag = document.createElement('style');\n\tconst links: HTMLLinkElement[] = []\n\tconst styles: HTMLStyleElement[] = [styleTag]\n\n\tArray.from(div.childNodes).forEach(child => {\n\t\tif (child.nodeName === 'LINK' && ((child as HTMLLinkElement).getAttribute('rel') || '').trim() === 'stylesheet') {\n\t\t\tlinks.push(child as HTMLLinkElement);\n\t\t} else if (child.nodeName === 'STYLE') {\n\t\t\tstyles.push(child as HTMLStyleElement);\n\t\t} else if(child.nodeName === '#text') {\n\t\t\tstyleTag.appendChild(child);\n\t\t}\n\t});\n\n\tif (!hasShadowRoot) {\n\t\tlinks.forEach(link => {\n\t\t\tlink.classList.add(tagName);\n\t\t})\n\t\t\n\t\tfor (let style of styles) {\n\t\t\tstyle.classList.add(tagName);\n\t\t\tstyle.textContent = (style.innerHTML).replace(/:(host-context|host)(?:\\s*\\((.*?)\\))?/gmi, (_, h, s) => {\n\t\t\t\tif (h === 'host-context') {\n\t\t\t\t\treturn `${(s || '').trim()} ${tagName}`;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn `${tagName}${(s || '').trim()}`;\n\t\t\t})\n\t\t}\n\t}\n\n\treturn links.map(el => el.outerHTML).join('') + styles.filter(el => (el.textContent || '').trim()).map(el => el.outerHTML).join('');\n}\n", "export function resolveHtmlEntities(html: string): string {\n\tconst e = document.createElement('textarea');\n\te.innerHTML = html;\n\treturn e.textContent || '';\n}", "import {CWCO} from \"../../cwco\";\n\nexport function evaluateStringInComponentContext(\n\texecutable: string,\n\tcomponent: CWCO.WebComponent,\n\tnodeData: CWCO.ObjectLiteral = {}\n) {\n\tif (!executable.trim()) {\n\t\treturn '';\n\t}\n\n\tconst ctx = component.$context;\n\tconst keys = Array.from(new Set([\n\t\t...Object.getOwnPropertyNames(nodeData),\n\t\t...component.$properties,\n\t\t...Object.getOwnPropertyNames(ctx),\n\t]));\n\tconst values = keys.map((key: string) => {\n\t\treturn nodeData[key] ?? component[key] ?? ctx[key] ?? null\n\t})\n\n\treturn (\n\t\tnew Function(...keys, `\"use strict\";\\n return ${executable};`)\n\t).apply(component, values) ?? '';\n}\n", "export function jsonStringify(value: any): any {\n\tif (value && typeof value !== 'string') {\n\t\ttry {\n\t\t\tvalue = JSON.stringify(value);\n\t\t} catch (e) {\n\t\t}\n\t}\n\n\treturn value;\n}", "import {evaluateStringInComponentContext} from \"./evaluate-string-in-component-context\";\nimport {CWCO} from \"../../cwco\";\nimport {jsonStringify} from \"../../utils/json-stringify\";\n\nexport function resolveExecutables(\n\tstr: string,\n\tcomponent: CWCO.WebComponent,\n\tnodeData: CWCO.ObjectLiteral,\n\texecutables: Array<CWCO.Executable>\n) {\n\tconst parts: Array<any> = [];\n\tlet lastIndex = 0;\n\tlet isString = true;\n\n\tif (executables.length) {\n\t\tfor (let {from, to, executable} of executables) {\n\t\t\tif (lastIndex !== from) {\n\t\t\t\tparts.push(str.slice(lastIndex, from));\n\t\t\t}\n\n\t\t\tlastIndex = to + 1;\n\n\t\t\tconst res = evaluateStringInComponentContext(executable, component, nodeData);\n\n\t\t\tisString = isString && typeof res === 'string';\n\n\t\t\tparts.push(res)\n\t\t}\n\n\t\tif (lastIndex !== str.length) {\n\t\t\tparts.push(str.slice(lastIndex));\n\t\t}\n\t} else {\n\t\tparts.push(str);\n\t}\n\n\tif (!isString && parts.length === 1) {\n\t    return parts[0]\n\t}\n\n\treturn parts.map(jsonStringify).join('');\n}\n", "import {CWCO} from \"../../cwco\";\n\nexport function extractExecutableSnippetFromString(str: string, [start, end] = ['{', '}'], offset = 0) {\n\tconst stack = [];\n\tconst pattern = new RegExp(`[\\\\${start}\\\\${end}]`, 'g');\n\tlet snippets: CWCO.Executable[] = [];\n\tlet match;\n\tlet startingCurlyIndex: number;\n\n\twhile ((match = pattern.exec(str)) !== null) {\n\t\tconst char = match[0];\n\n\t\tif (char === start) {\n\t\t\tstack.push(match.index);\n\t\t} else if (char === end && stack.length) {\n\t\t\tstartingCurlyIndex = stack.pop() as number;\n\n\t\t\tif(!stack.length) {\n\t\t\t\tconst matchStr = str.slice(startingCurlyIndex + 1, match.index);\n\n\t\t\t\tif (matchStr) {\n\t\t\t\t\tfor (let j = 0; j < snippets.length; j++) {\n\t\t\t\t\t\tconst snippet = snippets[j];\n\n\t\t\t\t\t\tif ((snippet.from - offset) > startingCurlyIndex && (snippet.to - offset) < match.index) {\n\t\t\t\t\t\t\tsnippets.splice(j, 1)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tsnippets.push({\n\t\t\t\t\t\tfrom: startingCurlyIndex + offset,\n\t\t\t\t\t\tto: match.index + offset,\n\t\t\t\t\t\tmatch: `${start}${matchStr}${end}`,\n\t\t\t\t\t\texecutable: matchStr\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn snippets;\n}\n", "import {CWCO} from \"../cwco\";\n\nexport const slotTag = (node: HTMLSlotElement, {component}: CWCO.ObjectLiteral = {}, cb: (n: Node[]) => void): void => {\n\tlet nodes: Node[] = [];\n\t\n\tif (component.type === 'context') {\n\t\tnodes = renderCustomSlot(node, component.childNodes)\n\t} else {\n\t\tnodes = getSlotAssignedNodes(component.childNodes, node.getAttribute('name') || '')\n\t}\n\t\n\tcb(nodes);\n}\n\nfunction renderCustomSlot(node: HTMLSlotElement, childNodes: Array<Node>) {\n\tconst name = node.getAttribute('name') || '';\n\tlet nodeList = getSlotAssignedNodes(childNodes, name);\n\tlet comment = document.createComment(`slotted [${name || ''}]`);\n\tnode.parentNode?.replaceChild(comment, node);\n\t\n\tif (!nodeList.length) {\n\t\tnodeList = Array.from(node.childNodes);\n\t}\n\t\n\tlet anchor: Node = comment;\n\t\n\tfor (let n of nodeList) {\n\t\t(anchor as Element).after(n);\n\t\tanchor = n;\n\t}\n\t\n\tcomment.parentNode?.removeChild(comment);\n\t\n\treturn nodeList;\n}\n\nfunction getSlotAssignedNodes(childNodes: Array<Node> = [], name: string = ''): Node[] {\n\tif (name) {\n\t\treturn childNodes.filter(n => {\n\t\t\treturn n.nodeType === 1 && (n as HTMLElement).getAttribute('slot') === name;\n\t\t});\n\t}\n\t\n\treturn childNodes.filter(n => {\n\t\treturn n.nodeType !== 1 || !(n as HTMLElement).hasAttribute('slot');\n\t});\n}\n\n", "import {CWCO} from \"../../cwco\";\nimport {extractExecutableSnippetFromString} from \"./extract-executable-snippet-from-string\";\n\nexport function extractExecutableSnippetFromCSS(\n\tcss: string,\n) {\n\tconst pattern = /[\\{\\}]/g;\n\tlet snippets: CWCO.Executable[] = [];\n\tconst stack: number[] = [];\n\tlet match;\n\n\twhile ((match = pattern.exec(css)) !== null) {\n\t\tconst char = match[0];\n\n\t\tif (char === '{') {\n\t\t\tstack.push(match.index);\n\t\t} else if(char === '}') {\n\t\t\tif (stack.length === 1) {\n\t\t\t\tsnippets.push(\n\t\t\t\t\t...extractExecutableSnippetFromString(\n\t\t\t\t\t\tcss.slice(stack[0], match.index),\n\t\t\t\t\t\t['[', ']'],\n\t\t\t\t\t\tstack[0]\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tstack.pop();\n\t\t}\n\t}\n\n\treturn snippets;\n}\n", "import {CWCO} from \"../../cwco\";\n\nexport function parseNodeDirective(node: Element, name: string, value: string): CWCO.DirectiveValue {\n\tconst dot = name.indexOf('.');\n\tlet prop = null;\n\n\tif (dot >= 0) {\n\t\tprop = name.slice(dot + 1);\n\t\tname = name.slice(0, dot).toLowerCase();\n\t}\n\n\treturn {name, value, prop};\n}\n", "import {CWCO} from \"../../cwco\";\n\nexport function getEventHandlerFunction(component: CWCO.WebComponent, nodeData: CWCO.ObjectLiteral, attribute: Attr): CWCO.EventListenerCallback {\n\tconst props = Array.from(new Set([...Object.getOwnPropertyNames(nodeData), ...component.$properties]));\n\tconst values = props.map(k => {\n\t\treturn nodeData[k] ?? component[k] ?? null;\n\t});\n\tconst value = attribute.value.trim()\n\tconst match = value.match(/^(?:((?:this\\.)?([a-z$_][a-z0-9$_\\\\.]*)\\s*\\((.*)\\))|\\{(.*)\\})$/i);\n\tlet func: Function;\n\n\tif (match) {\n\t\tlet [_, fn, fnName, fnArgs, executable] = match;\n\n\t\tif (executable) {\n\t\t\tfunc = new Function('$event', ...props, `\"use strict\";\\n ${executable};`);\n\t\t} else {\n\t\t\t// @ts-ignore\n\t\t\tif (typeof component[fnName] === 'function') {\n\t\t\t\tfn = fn.replace(/^this\\./, '');\n\t\t\t\tfunc = new Function('$event', ...props, `\"use strict\";\\n this.${fn}`);\n\t\t\t} else {\n\t\t\t\tfunc = new Function('$event', ...props, `\"use strict\";\\n ${fn}`);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfunc = new Function('$event', ...props, `\"use strict\";\\n ${value}`);\n\t}\n\n\treturn (event: Event) => func.call(component, event, ...values);\n}\n", "import {CWCO} from \"../cwco\";\nimport {TrackType} from \"../enums/track-type\";\n\nexport class Track {\n\tpublic executables: CWCO.Executable[] = [];\n\tpublic handler: CWCO.DirectiveConstructor | null = null;\n\tpublic prop: string | null = null;\n\tpublic prevValue: any = null;\n\n\tconstructor(\n\t\tpublic name: string,\n\t\tpublic value: string,\n\t\tpublic type: TrackType = TrackType.attribute\n\t) {\n\t}\n}", "import {CWCO} from \"../cwco\";\nimport {$} from \"../core/$\";\nimport {extractExecutableSnippetFromCSS} from \"./utils/extract-executable-snippet-from-css\";\nimport {directiveRegistry} from \"../directives/registry\";\nimport {parseNodeDirective} from \"./utils/parse-node-directive\";\nimport {getEventHandlerFunction} from \"./utils/get-event-handler-function\";\nimport {extractExecutableSnippetFromString} from \"./utils/extract-executable-snippet-from-string\";\nimport {TrackType} from \"../enums/track-type\";\nimport {Track} from \"./track\";\nimport {defineNodeContextMetadata} from \"./utils/define-node-context-metadata\";\n\nexport const trackNode = (node: Node | HTMLElement, component: CWCO.WebComponent): CWCO.TracksMapByType => {\n\tconst tracks: CWCO.TracksMapByType = {\n\t\tdirective: [],\n\t\tattribute: [],\n\t\tproperty: [],\n\t};\n\n\tdefineNodeContextMetadata(node)\n\t// because there are certain actions here that will modify the node itself like removing attributes\n\t// we can preserve the original node string representation to recreate it if necessary later\n\t$.get(node).rawNodeString = (node.nodeType === 3 ? node.nodeValue : (node as HTMLElement).outerHTML) || '';\n\n\tlet {nodeName, nodeValue, nodeType, textContent, attributes} = node as HTMLElement;\n\tlet track = null;\n\tnodeValue = nodeValue || '';\n\ttextContent = textContent || '';\n\n\tswitch (nodeName) {\n\t\tcase '#text':\n\t\t\ttrack = getNodeTrack('nodeValue', nodeValue)\n\t\t\tif (track) {\n\t\t\t\ttracks.property.push(track);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'TEXTAREA':\n\t\t\ttrack = getNodeTrack('textContent', textContent)\n\t\t\tif (track) {\n\t\t\t\ttracks.property.push(track);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'STYLE':\n\t\t\ttrack = getNodeTrack('textContent', textContent, TrackType.property, extractExecutableSnippetFromCSS)\n\t\t\tif (track) {\n\t\t\t\ttracks.property.push(track);\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tif (nodeType === 1) {\n\t\tconst dirPattern = new RegExp(`^(${Object.keys(directiveRegistry).join('|')})\\\\.?`);\n\t\tconst eventHandlers: Array<CWCO.EventHandlerTrack> = [];\n\t\tconst attrs: Attr[] = [];\n\n\t\t// @ts-ignore\n\t\t[...attributes].forEach((attr, i) => {\n\t\t\tif (dirPattern.test(attr.name)) {\n\t\t\t\tconst {name, value, prop} = parseNodeDirective(node as HTMLElement, attr.name, attr.value);\n\t\t\t\tconst dir = directiveRegistry[name];\n\n\t\t\t\ttrack = new Track(name, value, TrackType.directive);\n\t\t\t\ttrack.prop = prop;\n\t\t\t\ttrack.handler = dir;\n\n\t\t\t\tif(name === 'if') {\n\t\t\t\t\ttracks.directive[0] = track;\n\t\t\t\t} else if(name === 'repeat') {\n\t\t\t\t\ttracks.directive[1] = track;\n\t\t\t\t} else {\n\t\t\t\t\ttracks.directive[i + 2] = track;\n\t\t\t\t}\n\n\t\t\t\t(node as HTMLElement).removeAttribute(attr.name);\n\t\t\t} else if (attr.name.startsWith('on')) {\n\t\t\t\teventHandlers.push({\n\t\t\t\t\teventName: attr.name.slice(2).toLowerCase(),\n\t\t\t\t\tattribute: attr\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tattrs.push(attr)\n\t\t\t}\n\t\t})\n\n\t\ttracks.directive = Object.values(tracks.directive); // to eliminate empty slots\n\n\t\teventHandlers.forEach(({eventName, fn, attribute}) => {\n\t\t\t(node as HTMLElement).removeAttribute(attribute.name);\n\n\t\t\tif (!fn) {\n\t\t\t\tnode.addEventListener(eventName, getEventHandlerFunction(component, $.get(node).$context, attribute));\n\t\t\t}\n\t\t});\n\n\t\tfor (let attr of attrs) {\n\t\t\tif (attr.value.trim()) {\n\t\t\t\ttrack = getNodeTrack(attr.name, attr.value, TrackType.attribute)\n\t\t\t\tif (track) {\n\t\t\t\t\ttracks.attribute.push(track);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn tracks;\n}\n\nfunction getNodeTrack(name: string, value: string, type: TrackType = TrackType.property, extractor = extractExecutableSnippetFromString) {\n\tif ((value || '').trim()) {\n\t\tconst track = new Track(name, value, type);\n\t\ttrack.executables = extractor(value);\n\n\t\tif (track.executables.length) {\n\t\t\treturn track;\n\t\t}\n\t}\n\n\treturn null;\n}\n", "import {CWCO} from \"../cwco\";\nimport {$} from \"../core/$\";\nimport {slotTag} from \"../tags/slot.tag\";\nimport {defineNodeContextMetadata} from \"./utils/define-node-context-metadata\";\nimport {NodeTrack} from \"./node-track\";\nimport {trackNode} from \"./track-node\";\n\nexport const trackNodeTree = (node: Node | CWCO.WebComponent | HTMLElement, ancestorNodeTrack: NodeTrack, component: CWCO.WebComponent) => {\n\tconst {nodeName, nodeValue, childNodes, nodeType} = node;\n\n\t// if the track already exist simply push it to the ancestor\n\tif ($.get(node)?.track) {\n\t\tancestorNodeTrack.childNodeTracks.add($.get(node)?.track);\n\t\treturn;\n\t}\n\n\tif (nodeType !== 11) {\n\t\tdefineNodeContextMetadata(node);\n\t}\n\n\t// skip comments and empty text nodes to save unnecessary processing\n\tif (nodeName === '#comment' || (nodeName === '#text' && !nodeValue?.trim())) {\n\t\treturn;\n\t}\n\n\tif (nodeName === 'SLOT') {\n\t\tslotTag(node as HTMLSlotElement, {\n\t\t\tcomponent: {\n\t\t\t\ttype: component.customSlot ? 'context' : 'default',\n\t\t\t\tchildNodes: component._childNodes\n\t\t\t}\n\t\t}, (nodes: Node[]) => {\n\t\t\tnodes.forEach(node => {\n\t\t\t\ttrackNodeTree(node, ancestorNodeTrack, component);\n\t\t\t})\n\t\t})\n\t} else if ((nodeType === 1 || nodeType === 3)) {\n\t\tconst tracks = trackNode(node, component);\n\t\tconst isComponentNode = nodeName.includes('-');\n\n\t\t// collect the node track if it is a web component node\n\t\t// ,or it is just a node with tracks;\n\t\tif (isComponentNode || (tracks.attribute.length || tracks.property.length || tracks.directive.length)) {\n\t\t\tconst nodeTrack = new NodeTrack(node, component, tracks);\n\t\t\t$.get(node).track = nodeTrack;\n\t\t\tancestorNodeTrack.childNodeTracks.add(nodeTrack);\n\t\t\tancestorNodeTrack = nodeTrack; // continue collecting for this node track\n\t\t}\n\n\t\t// no need to continue for inside these tags either because:\n\t\t// - contains content which we don't want to deal with (script)\n\t\t// - content is already handled by the \"trackNode\" function\n\t\tif (/SCRIPT|STYLE|TEXTAREA|#text/i.test(nodeName)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tArray.from(childNodes).forEach(c => trackNodeTree(c, ancestorNodeTrack, component));\n}\n", "import {CWCO} from \"../cwco\";\nimport {defineNodeContextMetadata} from \"./utils/define-node-context-metadata\";\nimport {$} from \"../core/$\";\nimport {resolveExecutables} from \"./utils/resolve-executables\";\nimport {isPrimitive} from \"../utils/is-primitive\";\nimport {extractExecutableSnippetFromString} from \"./utils/extract-executable-snippet-from-string\";\nimport {evaluateStringInComponentContext} from \"./utils/evaluate-string-in-component-context\";\nimport {trackNodeTree} from \"./track-node-tree\";\n\nexport class NodeTrack {\n\t#compiled = false;\n\tchildNodeTracks = new Set<NodeTrack>();\n\tanchor: HTMLElement | Node | Comment | Array<Element>;\n\tanchorNodeTrack: NodeTrack | null = null;\n\tanchorTrack: CWCO.Track | null = null;\n\treadonly dirs = new WeakMap();\n\treadonly dirAnchors = new WeakMap();\n\n\tconstructor(\n\t\tpublic node: Node | HTMLElement | CWCO.WebComponent,\n\t\tpublic component: CWCO.WebComponent,\n\t\tpublic tracks: CWCO.TracksMapByType = {directive: [], attribute: [], property: []}\n\t) {\n\t\tdefineNodeContextMetadata(node);\n\n\t\tif (node.nodeType !== 8) {\n\t\t\tthis.anchorNodeTrack = new NodeTrack(document.createComment($.get(node).rawNodeString), component)\n\t\t}\n\n\t\tthis.anchor = node;\n\t}\n\n\tget $context() {\n\t\t// use this track node context if it does not happen to be anchored\n\t\t// otherwise the anchor context will reflect its ancestor's context\n\t\treturn (this.anchor === this.node\n\t\t\t? $.get(this.node).$context\n\t\t\t: $.get(\n\t\t\t\tArray.isArray(this.anchor)\n\t\t\t\t\t? (this.anchor as Array<Element>)[0]\n\t\t\t\t\t: this.anchor\n\t\t\t)?.$context) || {};\n\t}\n\t\n\tget compiled() {\n\t\treturn this.#compiled;\n\t}\n\n\tupdateNode(force = false) {\n\t\t// if it is a text node\n\t\tif (this.node.nodeType === 3) {\n\t\t\tfor (let t of this.tracks.property) {\n\t\t\t\tthis._updateNodeProperty(t)\n\t\t\t}\n\t\t} else {\n\t\t\tconst empty = !this.tracks.directive.length &&\n\t\t\t\t!this.tracks.attribute.length &&\n\t\t\t\t!this.tracks.property.length;\n\n\t\t\tfor (let t of this.tracks.directive) {\n\t\t\t\tconst dirNode = this._updateNodeDirective(t);\n\n\t\t\t\tif (dirNode) {\n\t\t\t\t\tthis._swapNodeAndDirNode(dirNode);\n\t\t\t\t\tthis.anchor = dirNode;\n\n\t\t\t\t\tif (dirNode !== this.node) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let t of this.tracks.attribute) {\n\t\t\t\tthis._updateNodeAttribute(t)\n\t\t\t}\n\n\t\t\tfor (let t of this.tracks.property) {\n\t\t\t\tthis._updateNodeProperty(t)\n\t\t\t}\n\n\t\t\t// for empty web component with no tracks needs to\n\t\t\t// be force updated if force is True since\n\t\t\t// there is nothing that will trigger update inside the\n\t\t\t// component like attribute tracks would\n\t\t\tif (empty && force && this.node.nodeName.includes('-') && typeof (this.node as CWCO.WebComponent).forceUpdate == 'function') {\n\t\t\t\t(this.node as CWCO.WebComponent).forceUpdate();\n\t\t\t}\n\n\t\t\tthis.childNodeTracks.forEach(t => {\n\t\t\t\tt.updateNode(force);\n\t\t\t})\n\t\t}\n\t\t\n\t\tthis.#compiled = true;\n\t}\n\n\tprivate _removeNodeDirectiveAttribute(n: Node | HTMLElement) {\n\t\tif (n.nodeType === 1) {\n\t\t\t(n as HTMLElement).removeAttribute(this.anchorTrack?.name || '')\n\t\t}\n\t}\n\n\tprivate _updateNodeProperty(track: CWCO.Track) {\n\t\tconst newValue = resolveExecutables(\n\t\t\ttrack.value,\n\t\t\tthis.component,\n\t\t\tthis.$context,\n\t\t\ttrack.executables\n\t\t);\n\n\t\tif (!isPrimitive(newValue) || newValue !== (this.node as CWCO.ObjectLiteral)[track.name]) {\n\t\t\t(this.node as CWCO.ObjectLiteral)[track.name] = newValue;\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate _updateNodeAttribute(track: CWCO.Track) {\n\t\tlet newValue = resolveExecutables(\n\t\t\ttrack.value,\n\t\t\tthis.component,\n\t\t\tthis.$context,\n\t\t\ttrack.executables\n\t\t);\n\n\t\tif (isPrimitive(newValue)) {\n\t\t\tif ((this.node as HTMLElement).getAttribute(track.name) !== newValue) {\n\t\t\t\t(this.node as HTMLElement).setAttribute(track.name, newValue);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tconst {attrPropsMap} = $.get(this.node);\n\t\t\tconst attrProp = attrPropsMap ? attrPropsMap[track.name] : track.name;\n\n\t\t\tif ((this.node as HTMLElement).hasAttribute(track.name)) {\n\t\t\t\t$.get(this.node).clearAttr = true;\n\t\t\t\t(this.node as HTMLElement).removeAttribute(track.name);\n\t\t\t}\n\n\n\t\t\t(this.node as CWCO.ObjectLiteral)[attrProp] = newValue;\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate _updateNodeDirective(track: CWCO.Track) {\n\t\tif (track.handler) {\n\t\t\tconst {handler} = track;\n\t\t\tconst dir = this.dirs.get(track) || new handler(this.component);\n\t\t\tthis.dirs.set(track, dir);\n\n\t\t\tlet val = dir.parseValue(track.value, track.prop);\n\n\t\t\tlet value = resolveExecutables(\n\t\t\t\tval,\n\t\t\t\tthis.component,\n\t\t\t\tthis.$context,\n\t\t\t\textractExecutableSnippetFromString(val)\n\t\t\t);\n\n\t\t\tif (typeof value === 'string') {\n\t\t\t\tvalue = evaluateStringInComponentContext(value, this.component, this.$context);\n\t\t\t}\n\n\t\t\tif (track.prevValue !== value) {\n\t\t\t\ttrack.prevValue = value;\n\n\t\t\t\tconst dirNode = dir.render(value, {\n\t\t\t\t\telement: this.node,\n\t\t\t\t\tanchorNode: this.dirAnchors.get(track) ?? null,\n\t\t\t\t\trawElementOuterHTML: $.get(this.node).rawNodeString\n\t\t\t\t} as CWCO.directiveRenderOptions);\n\n\t\t\t\tif (dirNode !== this.node) {\n\t\t\t\t\tthis.dirAnchors.set(track, dirNode);\n\t\t\t\t\tthis.anchorTrack = track;\n\t\t\t\t}\n\n\t\t\t\treturn dirNode;\n\t\t\t} else if(this.anchorTrack === track) {\n\t\t\t\t// if this directive happens to be the one which cause this node to be anchored\n\t\t\t\t// and its value did not change, we can just quit the updating al together\n\t\t\t\t// since nothing else will update this node\n\t\t\t\treturn this.anchor;\n\t\t\t}\n\n\t\t\tthis.dirAnchors.set(track, null)\n\t\t}\n\n\t\treturn this.node;\n\t}\n\n\tprivate _swapNodeAndDirNode(dirNode: HTMLElement | Node | Comment | Array<Element>) {\n\t\tif (dirNode === this.anchor) {\n\t\t\treturn;\n\t\t}\n\n\t\t// clear previous child node tracks before pushing all new ones\n\t\t// to ensure that the updates will only be applied to these new tracks\n\t\t(this.anchorNodeTrack as NodeTrack)?.childNodeTracks.clear();\n\n\t\t// since new nodes are not initially tracked by the component\n\t\t// we need to track them as part of the anchor node branch\n\t\t// so when there are changes to the anchored node\n\t\t// these are tracked and updated separately from the original node\n\t\tif (Array.isArray(dirNode)) {\n\t\t\tdirNode.forEach(n => {\n\t\t\t\tthis._removeNodeDirectiveAttribute(n);\n\t\t\t\ttrackNodeTree(n, this.anchorNodeTrack as NodeTrack, this.component)\n\t\t\t})\n\t\t} else {\n\t\t\tthis._removeNodeDirectiveAttribute(dirNode);\n\t\t\ttrackNodeTree(dirNode as Node, this.anchorNodeTrack as NodeTrack, this.component)\n\t\t}\n\t\t\n\t\tthis.anchorNodeTrack?.childNodeTracks.forEach((t: NodeTrack) => {\n\t\t\tt.updateNode();\n\t\t})\n\n\t\tif (dirNode !== this.node) {\n\t\t\tthis.anchorNodeTrack?.childNodeTracks.forEach((t: NodeTrack) => {\n\t\t\t\tt.updateNode();\n\t\t\t})\n\t\t}\n\n\t\tlet dirIsArray = Array.isArray(dirNode);\n\n\t\t// in case we have an empty array of nodes or simply that\n\t\t// the nodes are ar not valid nodes types (text, comment, element)\n\t\t// we will override to use the anchor node which is a comment node\n\t\tif (\n\t\t\t(dirIsArray && !(dirNode as Array<Element>).length) ||\n\t\t\t(!dirIsArray && !(/[831]/.test(`${(dirNode as Node).nodeType}`)))\n\t\t) {\n\t\t\tdirNode = (this.anchorNodeTrack as NodeTrack).node;\n\t\t\tdirIsArray = false;\n\t\t}\n\n\t\tconst anchorIsArray = Array.isArray(this.anchor);\n\t\t// in case the anchor node is currently empty, it means it had a anchor\n\t\t// node comment render instead as the above if statement make sure of.\n\t\t// in that regard we need to use so we can replace whats it is currently\n\t\t// on the dom as an anchor\n\t\tconst anchorEl = anchorIsArray && !(this.anchor as Array<Element>).length\n\t\t\t? (this.anchorNodeTrack as NodeTrack).node as Comment\n\t\t\t: document.createComment('cw');\n\t\tlet nextEl: Element | Comment | Text = anchorEl;\n\n\t\tif (anchorIsArray) {\n\t\t\t// here we use the dir node first element or the anchor node\n\t\t\t// to place the anchor element to begin the swapping process\n\t\t\tconst el = !(this.anchor as Array<Element>).length\n\t\t\t\t? (this.anchorNodeTrack as NodeTrack).node\n\t\t\t\t: (this.anchor as Array<Element>)[0];\n\t\t\tel?.parentNode?.insertBefore(nextEl, el);\n\t\t} else {\n\t\t\t(this.anchor as Node).parentNode?.insertBefore(nextEl, this.anchor as Node);\n\t\t}\n\n\t\tif (dirIsArray) {\n\t\t\t// for each dir node in the array we place on the dom after\n\t\t\t// the previous as long as it was not in the dom before\n\t\t\t// this will ensure the nodes are placed sequentially\n\t\t\t// and not remounted to avoid un updates in case they are\n\t\t\t// web component nodes\n\t\t\tfor (let el of (dirNode as Array<Element>)) {\n\t\t\t\tif (!el.isConnected) {\n\t\t\t\t\tnextEl.after(el);\n\t\t\t\t}\n\n\t\t\t\tnextEl = el;\n\t\t\t}\n\t\t} else if(dirNode instanceof Node) {\n\t\t\tnextEl.after(dirNode as Node);\n\t\t}\n\n\t\tif (anchorIsArray) {\n\t\t\t// here we start the process of cleaning up any old node\n\t\t\t// placed before in the previous dir node list\n\t\t\t// which is not part of the new dir node list\n\t\t\tfor (let el of (this.anchor as Array<Element>)) {\n\t\t\t\tif (!dirIsArray || !(dirNode as Array<Element>).includes(el)) {\n\t\t\t\t\tel.parentNode?.removeChild(el);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.anchor !== dirNode) {\n\t\t\t(this.anchor as Node).parentNode?.removeChild(this.anchor as Node);\n\t\t}\n\n\t\t// remove the node which served as the anchor on the dom for the node swap\n\t\tanchorEl.parentNode?.removeChild(anchorEl);\n\t}\n}\n", "import {CWCO} from \"../../cwco\";\nimport {turnCamelToKebabCasing} from \"../../utils/turn-camel-to-kebab-casing\";\n\ntype callback = (str: string | null, declaration?: string) => void\n\nexport function JSONToCSS(obj: CWCO.ObjectLiteral) {\n\treturn Object.keys(obj).map(prop => createPropertyBody(prop, obj[prop])).join('').trim();\n}\n\nfunction getPropertyCSS(prop: string, value: CWCO.StylesheetObject, parentProp: string, cb: callback) {\n\tprop = prop.trim();\n\t\n\tif(prop.startsWith('&')) {\n\t\tcb(null, createPropertyBody(parentProp + prop.slice(1).trim(), value));\n\t} else if(prop.startsWith('@')) {\n\t\tcb(null, createPropertyBody(prop, value))\n\t} else if(typeof value === 'object') {\n\t\tif (parentProp.startsWith('@')) {\n\t\t\tcb(createPropertyBody(prop, value))\n\t\t} else {\n\t\t\tcb(null, createPropertyBody(`${parentProp} ${prop}`, value))\n\t\t}\n\t} else {\n\t\tcb(`${turnCamelToKebabCasing(prop)}: ${value};`);\n\t}\n}\n\nfunction createPropertyBody(prop: string, value: CWCO.ObjectLiteral): string {\n\tconst declarations = [];\n\tlet declaration = `${prop} {`;\n\t\n\tObject.keys(value).forEach(childProp => getPropertyCSS(childProp, value[childProp], prop, (pair, newDeclaration = '') => {\n\t\tif(pair) {\n\t\t\tdeclaration += pair;\n\t\t} else {\n\t\t\tdeclarations.push(newDeclaration);\n\t\t}\n\t}));\n\t\n\tdeclaration += '} ';\n\t\n\tdeclarations.unshift(declaration);\n\t\n\treturn declarations.join('');\n}\n", "// simply importing directive here will automatically register them and make them available for\n// anything later on\nimport '../directives';\nimport booleanAttr from './boolean-attributes.json';\nimport {$} from \"./$\";\nimport {parse} from '../parser/parse';\nimport {setComponentPropertiesFromObservedAttributes} from './utils/set-component-properties-from-observed-attributes';\nimport {setupComponentPropertiesForAutoUpdate} from './utils/setup-component-properties-for-auto-update';\nimport {turnCamelToKebabCasing} from '../utils/turn-camel-to-kebab-casing';\nimport {turnKebabToCamelCasing} from '../utils/turn-kebab-to-camel-casing';\nimport {getStyleString} from './utils/get-style-string';\nimport {ShadowRootModeExtended} from \"../enums/ShadowRootModeExtended.enum\";\nimport {jsonParse} from \"../utils/json-parse\";\nimport {resolveHtmlEntities} from \"../utils/resolve-html-entities\";\nimport {CWCO} from \"../cwco\";\nimport {NodeTrack} from \"../tracker/node-track\";\nimport {trackNodeTree} from \"../tracker/track-node-tree\";\nimport {JSONToCSS} from \"./utils/json-to-css\";\n\n/**\n * a extension on the native web component API to simplify and automate most of the pain points\n * when it comes to creating and working with web components on the browser\n */\nexport class WebComponent extends HTMLElement implements CWCO.WebComponent {\n\treadonly $refs: CWCO.Refs = {};\n\t$properties: Array<string> = ['$context', '$refs'];\n\t/**\n\t * the id of the template tag placed in the body of the document which contains the template content\n\t */\n\ttemplateId: string = '';\n\t_childNodes: Array<Node> = [];\n\t\n\tconstructor() {\n\t\tsuper();\n\n\t\tlet {mode, observedAttributes, delegatesFocus} = this.constructor as CWCO.WebComponentConstructor;\n\n\t\tconst selfTrack = new NodeTrack(this, this)\n\t\tconst meta = $.get(this);\n\n\t\tmeta.root = this;\n\t\tmeta.mounted = false;\n\t\tmeta.parsed = false;\n\t\tmeta.clearAttr = false;\n\t\tmeta.selfTrack = selfTrack;\n\t\tmeta.externalNodes = []; // nodes moved outside the component that needs to be updated on ctx change\n\t\tmeta.attrPropsMap = observedAttributes.reduce((map, attr) => ({\n\t\t\t...map,\n\t\t\t[attr]: turnKebabToCamelCasing(attr)\n\t\t}), {} as CWCO.ObjectLiteral);\n\n\t\tif (mode !== 'none') {\n\t\t\t$.get(this).root = this.attachShadow({mode, delegatesFocus});\n\t\t}\n\t}\n\t\n\t/**\n\t * an array of attribute names as they will look in the html tag\n\t * https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elementsusing_the_lifecycle_callbacks\n\t * @type {[]}\n\t */\n\tstatic observedAttributes: Array<string> = [];\n\t\n\t/**\n\t * shadow root mode\n\t * https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot/mode\n\t * plus an additional option of \"none\" to signal you dont want\n\t * the content to be places inside the shadow root but directly under the tag\n\t * @type {string}\n\t */\n\tstatic mode = ShadowRootModeExtended.OPEN;\n\t\n\t/**\n\t * shadow root delegate focus option\n\t * https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot/delegatesFocus\n\t * @type {boolean}\n\t */\n\tstatic delegatesFocus = false;\n\t\n\t/**\n\t * a valid name of the html tag\n\t * @type {string}\n\t */\n\tstatic tagName = '';\n\t\n\t/**\n\t * the initial context data for the component\n\t */\n\tstatic initialContext = {};\n\t\n\t/**\n\t * parses special template HTML string taking in consideration\n\t * all the additional syntax specific to this framework\n\t */\n\tstatic parseHTML(markup: string): DocumentFragment {\n\t\treturn parse(markup)\n\t}\n\t\n\t/**\n\t * registers the component with the CustomElementRegistry taking an optional tag name if not\n\t * specified as static member of the class as tagName\n\t * @param tagName\n\t */\n\tstatic register(tagName?: string | undefined) {\n\t\tif (this.name !== 'WebComponent') {\n\t\t\ttagName = typeof tagName === 'string' && tagName\n\t\t\t\t? tagName\n\t\t\t\t: typeof this.tagName === 'string' && this.tagName\n\t\t\t\t\t? this.tagName\n\t\t\t\t\t: turnCamelToKebabCasing(this.name);\n\t\t\t\n\t\t\tthis.tagName = tagName;\n\t\t\t\n\t\t\tif (!customElements.get(tagName)) {\n\t\t\t\tcustomElements.define(tagName, this);\n\t\t\t}\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tconsole.warn(\"Can't 'register' 'WebComponent' class itself\")\n\t}\n\t\n\t/**\n\t * registers a list of provided web component classes\n\t * @param comps\n\t */\n\tstatic registerAll(comps: Array<CWCO.WebComponentConstructor>) {\n\t\tif (this.name === 'WebComponent') {\n\t\t\treturn comps.forEach(comp => comp.register());\n\t\t}\n\t\t\n\t\tconsole.warn(\"Please use 'WebComponent' to 'registerAll'\")\n\t}\n\t\n\t/**\n\t * returns whether the component is registered or not\n\t */\n\tstatic get isRegistered() {\n\t\treturn customElements.get(this.tagName) !== undefined;\n\t}\n\t\n\t/**\n\t * template for the element HTML content\n\t */\n\tget template(): string {\n\t\treturn '';\n\t};\n\t\n\t/**\n\t * style for the component whether inside the style tag, as object or straight CSS string\n\t */\n\tget stylesheet(): CWCO.Stylesheet {\n\t\treturn '';\n\t};\n\t\n\t/**\n\t * whether the component should use the real slot element or mimic its behavior\n\t * when rendering template\n\t */\n\tget customSlot() {\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * the root element. If shadow root present it will be the shadow root otherwise\n\t * the actual element\n\t * @returns {*}\n\t */\n\tget root(): HTMLElement | ShadowRoot | null {\n\t\treturn (this.constructor as CWCO.WebComponentConstructor).mode === 'closed' ? null : $.get(this).root;\n\t}\n\t\n\t/**\n\t * whether or not the element is attached to the DOM and works differently than Element.isConnected\n\t * @returns {boolean}\n\t */\n\tget mounted() {\n\t\treturn $.get(this)?.mounted ?? false;\n\t}\n\t\n\tget parsed() {\n\t\treturn $.get(this).parsed;\n\t}\n\t\n\tget $context(): CWCO.ObjectLiteral {\n\t\treturn $.get(this).$context;\n\t}\n\t\n\tupdateContext(ctx: CWCO.ObjectLiteral) {\n\t\tconst {oldCtx, newCtx} = $.get(this).updateContext(ctx);\n\n\t\t$.get(this).selfTrack.childNodeTracks.forEach((t: NodeTrack) => {\n\t\t\tt.updateNode(true);\n\t\t})\n\n\t\tthis.onUpdate('$context', oldCtx, newCtx);\n\t}\n\t\n\tconnectedCallback() {\n\t\tconst {initialContext, observedAttributes, tagName, mode} = this.constructor as CWCO.WebComponentConstructor;\n\t\tconst {parsed, selfTrack, root, attrPropsMap} = $.get(this);\n\n\t\tif (Object.keys(initialContext).length) {\n\t\t\t$.get(this).updateContext(initialContext);\n\t\t}\n\n\t\tconst onPropUpdate = (prop: string, oldValue: any, newValue: any) => {\n\t\t\tif (this.mounted) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.forceUpdate();\n\t\t\t\t\tthis.onUpdate(prop, oldValue, newValue);\n\t\t\t\t} catch(e) {\n\t\t\t\t\tthis.onError(e as ErrorEvent);\n\t\t\t\t}\n\t\t\t} else if(this.parsed) {\n\t\t\t\tthis.onError(new Error(`[Possibly a memory leak]: Cannot set property \"${prop}\" on unmounted component.`));\n\t\t\t}\n\t\t};\n\n\t\ttry {\n\n\t\t\t$.get(this).mounted = true;\n\n\t\t\t/*\n\t\t\tonly need to parse the element the very first time it gets mounted\n\n\t\t\tthis will make sure that if the element is removed from the dom and mounted again\n\t\t\tall that needs to be done if update the DOM to grab the possible new context and updated data\n\t\t\t */\n\t\t\tif (parsed) {\n\t\t\t\tthis.updateContext({});\n\t\t\t} else {\n\n\t\t\t\tthis.$properties.push(\n\t\t\t\t\t...setComponentPropertiesFromObservedAttributes(this, observedAttributes, attrPropsMap, onPropUpdate),\n\t\t\t\t\t...setupComponentPropertiesForAutoUpdate(this, onPropUpdate)\n\t\t\t\t)\n\t\t\t\t\n\t\t\t\tObject.freeze(this.$properties);\n\t\t\t\t\n\t\t\t\tconst hasShadowRoot = (this.constructor as CWCO.WebComponentConstructor).mode !== 'none';\n\t\t\t\tconst stylesheet = this.stylesheet;\n\t\t\t\tlet temp = this.template;\n\t\t\t\tlet style = '';\n\n\t\t\t\tif (!temp && this.templateId) {\n\t\t\t\t\tconst t = document.getElementById(this.templateId);\n\n\t\t\t\t\ttemp = t?.nodeName === 'TEMPLATE' ? t.innerHTML : temp;\n\t\t\t\t}\n\n\t\t\t\tif (stylesheet && mode !== 'none' || !getLinkAndStyleTagsFromHead(tagName).length) {\n\t\t\t\t\tstyle = typeof stylesheet === 'object'\n\t\t\t\t\t\t? `<style class=\"${tagName}\">${JSONToCSS(stylesheet)}</style>`\n\t\t\t\t\t\t: getStyleString(stylesheet, tagName.toLowerCase(), hasShadowRoot);\n\t\t\t\t}\n\n\t\t\t\tconst contentNode = parse(resolveHtmlEntities(style + temp));\n\n\t\t\t\tthis._childNodes = Array.from(this.childNodes);\n\t\t\t\t\n\t\t\t\tif (this.customSlot) {\n\t\t\t\t\tthis.innerHTML = '';\n\t\t\t\t}\n\n\t\t\t\ttrackNodeTree(contentNode, selfTrack, this);\n\n\t\t\t\tselfTrack.childNodeTracks.forEach((t: NodeTrack) => {\n\t\t\t\t\tt.updateNode();\n\t\t\t\t})\n\n\t\t\t\tif (mode === 'none') {\n\t\t\t\t\t[\n\t\t\t\t\t\t...Array.from(contentNode.querySelectorAll('link')),\n\t\t\t\t\t\t...Array.from(contentNode.querySelectorAll('style')),\n\t\t\t\t\t].forEach((el: HTMLElement) => {\n\t\t\t\t\t\tdocument.head.appendChild(el);\n\t\t\t\t\t\t$.get(this).externalNodes.push(el);\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\t$.get(this).parsed = true;\n\t\t\t\troot.appendChild(contentNode);\n\t\t\t}\n\t\t\t\n\t\t\tthis.onMount();\n\t\t} catch (e) {\n\t\t\tthis.onError(e as ErrorEvent);\n\t\t}\n\t}\n\t\n\t/**\n\t * livecycle callback for when the element is attached to the DOM\n\t */\n\tonMount() {\n\t}\n\t\n\tdisconnectedCallback() {\n\t\ttry {\n\t\t\t$.get(this).mounted = false;\n\t\t\tthis.onDestroy();\n\t\t} catch (e) {\n\t\t\tthis.onError(e as Error)\n\t\t}\n\t}\n\t\n\t/**\n\t * livecycle callback for when the element is removed from the DOM\n\t */\n\tonDestroy() {\n\t}\n\t\n\tattributeChangedCallback(name: string, oldValue: any, newValue: any) {\n\t\tif ($.get(this).clearAttr) {\n\t\t\t$.get(this).clearAttr = false;\n\t\t} else if (this.mounted) {\n\t\t\ttry {\n\t\t\t\tif (!(name.startsWith('data-') || name === 'class' || name === 'style')) {\n\t\t\t\t\tconst prop: any = $.get(this).attrPropsMap[name];\n\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tthis[prop] = booleanAttr.hasOwnProperty(prop)\n\t\t\t\t\t\t? this.hasAttribute(name)\n\t\t\t\t\t\t: jsonParse(newValue);\n\t\t\t\t} else {\n\t\t\t\t\tthis.forceUpdate();\n\t\t\t\t\tthis.onUpdate(name, oldValue, newValue);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tthis.onError(e as ErrorEvent)\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * livecycle callback for when the element attributes or class properties are updated\n\t */\n\tonUpdate(name: string, oldValue: unknown, newValue: unknown) {\n\t}\n\t\n\t/**\n\t * updates any already tracked node with current component data including context and node level data.\n\t */\n\tforceUpdate() {\n\t\t$.get(this).selfTrack.childNodeTracks.forEach((t: NodeTrack) => {\n\t\t\tt.updateNode();\n\t\t})\n\t}\n\t\n\tadoptedCallback() {\n\t\ttry {\n\t\t\tthis.onAdoption();\n\t\t} catch (e) {\n\t\t\tthis.onError(e as Error)\n\t\t}\n\t}\n\t\n\t/**\n\t * livecycle callback for when element is moved into a new document\n\t */\n\tonAdoption() {\n\t}\n\t\n\t/**\n\t * error callback for when an error occurs\n\t */\n\tonError(error: ErrorEvent | Error) {\n\t\tconsole.error(this.constructor.name, error);\n\t}\n}\n\nfunction getLinkAndStyleTagsFromHead(tagName: string) {\n\treturn [\n\t\t...Array.from(document.head.querySelectorAll(`link.${tagName}`.toLowerCase())),\n\t\t...Array.from(document.head.querySelectorAll(`style.${tagName}`.toLowerCase()))\n\t]\n}\n\n", "import {ShadowRootModeExtended} from \"../enums/ShadowRootModeExtended.enum\";\nimport {WebComponent} from \"./web-component\";\nimport {CWCO} from \"../cwco\";\n\n/**\n * a special WebComponent that handles slot tag differently allowing for render template right into HTML files\n */\nexport class ContextProviderComponent extends WebComponent implements CWCO.WebComponent  {\n\tget customSlot() {\n\t\treturn true;\n\t}\n\n\tstatic mode = ShadowRootModeExtended.NONE;\n\t\n\tget template() {\n\t\treturn '<slot></slot>';\n\t}\n\n\tget stylesheet() {\n\t\treturn ':host { display: block; }';\n\t}\n}\n", "export const html = (x: TemplateStringsArray) => x.join('');", "// cwco, copyright (c) by Elson Correia / Before Semicolon\n// Distributed under an MIT license: https://github.com/beforesemicolon/cwco/blob/master/LICENSE\nimport {WebComponent} from './core/web-component';\nimport {Directive} from './core/directive';\nimport {ContextProviderComponent} from './core/context-provider-component';\nimport {html} from \"./utils/html\";\n\n// @ts-ignore\nif (window) {\n\t// @ts-ignore\n\twindow.WebComponent = WebComponent;\n\t// @ts-ignore\n\twindow.ContextProviderComponent = ContextProviderComponent;\n\t// @ts-ignore\n\twindow.Directive = Directive;\n\t// @ts-ignore\n\twindow.html = html;\n}\n"],
  "mappings": "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",
  "names": []
}
