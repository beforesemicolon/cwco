{
  "version": 3,
  "sources": ["../src/directives/registry.ts", "../src/metadata.ts", "../src/utils/define-node-context-metadata.ts", "../src/directive.ts", "../src/directives/if.directive.ts", "../src/directives/ref.directive.ts", "../src/utils/turn-kebab-to-camel-casing.ts", "../src/utils/turn-camel-to-kebab-casing.ts", "../src/directives/attr.directive.ts", "../src/utils/parse.ts", "../src/directives/repeat.directive.ts", "../src/directives/bind.directive.ts", "../src/directives/index.ts", "../src/utils/proxify.ts", "../src/utils/json-parse.ts", "../src/utils/set-component-properties-from-observed-attributes.ts", "../src/utils/setup-component-properties-for-auto-update.ts", "../src/utils/get-style-string.ts", "../src/utils/extract-executable-snippet-from-string.ts", "../src/utils/parse-node-directive.ts", "../src/utils/evaluate-string-in-component-context.ts", "../src/utils/resolve-executable.ts", "../src/utils/get-component-node-event-listener.ts", "../src/utils/get-event-handler-function.ts", "../src/node-track.ts", "../src/tags/slot.tag.ts", "../src/utils/track-node.ts", "../src/utils/resolve-html-entities.ts", "../src/web-component.ts", "../src/context-provider-component.ts", "../src/client.ts"],
  "sourcesContent": ["import {CWCO} from \"../cwco\";\n\nexport const directiveRegistry: {[key: string]: CWCO.DirectiveConstructor} = {};\n", "/**\n * metadata is a simple global object that is used to store data related to the node\n * to prevent attaching properties on the node directly also to prevent this data\n * to be manipulated when user has reference of the node object.\n *\n * its weak nature also means that when no node reference exists, these data will simply be\n * garbage collected\n */\nexport const $: WeakMap<any, any> = new WeakMap();\n", "import {$} from \"../metadata\";\nimport {CWCO} from \"../cwco\";\n\nexport function defineNodeContextMetadata(node: Node) {\n\tif ($.has(node) && $.get(node)?.$context) {\n\t\treturn;\n\t}\n\n\tlet ctx: CWCO.ObjectLiteral = {};\n\tlet subs: Array<CWCO.ObserverCallback> = [];\n\tconst dt: CWCO.ObjectLiteral = $.get(node) || {};\n\n\tdt.subscribe = (cb: CWCO.ObserverCallback) => {\n\t\tsubs.push(cb);\n\t\treturn () => {\n\t\t\tsubs = subs.filter((c) => c !== cb);\n\t\t}\n\t}\n\n\tdt.updateContext = (newCtx: CWCO.ObjectLiteral | null = null) => {\n\t\tif (newCtx && typeof newCtx === 'object') {\n\t\t\tctx = {...ctx, ...newCtx};\n\t\t}\n\t\t\n\t\t// if the node is not tracked (contains no bound prop or attr)\n\t\t// or is a component node which calling updateNode ended up not changing anything\n\t\t// we can continue to propagate the context\n\t\t// this is because if a track node ends up updated, it will automatically\n\t\t// update all its inner tracker which will read the context just fine\n\t\tif (!$.get(node).track || (!$.get(node).track.updateNode() && node.nodeName.includes('-'))) {\n\t\t\tnotify();\n\t\t}\n\t}\n\n\tObject.defineProperty(dt, '$context', {\n\t\tget() {\n\t\t\treturn {...$.get(getParent(node))?.$context, ...ctx};\n\t\t}\n\t})\n\n\tfunction notify() {\n\t\t((node as CWCO.WebComponent).root ?? node).childNodes\n\t\t\t.forEach((n) => {\n\t\t\t\tif (typeof $.get(n)?.updateContext === 'function') {\n\t\t\t\t\t$.get(n).updateContext();\n\t\t\t\t}\n\t\t\t});\n\n\t\tsubs.forEach((cb) => {\n\t\t\tcb(dt.$context);\n\t\t});\n\t}\n\n\t$.set(node, dt);\n}\n\nfunction getParent(node: Node) {\n\treturn node.parentNode instanceof ShadowRoot\n\t\t? node.parentNode.host\n\t\t: node.parentNode\n}\n\n", "import {directiveRegistry} from \"./directives/registry\";\nimport {$} from \"./metadata\";\nimport {defineNodeContextMetadata} from \"./utils/define-node-context-metadata\";\nimport {CWCO} from \"./cwco\";\n\nexport class Directive implements CWCO.Directive  {\n\tconstructor(component: CWCO.WebComponent) {\n\t\t$.set(this, {component})\n\t}\n\n\tstatic register(name: string = '') {\n\t\tname = (name || this.name).toLowerCase();\n\n\t\tif (!directiveRegistry.hasOwnProperty(name)) {\n\t\t\tdirectiveRegistry[name] = this;\n\t\t}\n\t}\n\n\tparseValue(value: string, prop: string | null) {\n\t\treturn value;\n\t}\n\n\trender(val: unknown, {element}: CWCO.directiveRenderOptions): CWCO.directiveRenderOptions['anchorNode'] {\n\t\treturn element;\n\t}\n\n\tsetRef(name: string, node: Node) {\n\t\tconst currRef = $.get(this).component.$refs[name];\n\n\t\tif (currRef === undefined) {\n\t\t\t$.get(this).component.$refs[name] = node;\n\t\t} else if(Array.isArray(currRef)) {\n\t\t\t!currRef.includes(node) && currRef.push(node);\n\t\t} else if(currRef !== node) {\n\t\t\t$.get(this).component.$refs[name] = [currRef, node];\n\t\t}\n\t}\n\n\tgetContext(node: Node) {\n\t\treturn $.get(node).$context ?? null;\n\t}\n\n\tupdateContext(node: Node, newCtx: CWCO.ObjectLiteral) {\n\t\tdefineNodeContextMetadata(node);\n\t\t$.get(node)?.updateContext(newCtx);\n\t}\n}\n", "import {Directive} from \"../directive\";\nimport {CWCO} from \"../cwco\";\n\nexport class If extends Directive {\n\trender(condition: boolean, {element, anchorNode}: CWCO.directiveRenderOptions) {\n\t\treturn condition\n\t\t\t? element\n\t\t\t: (anchorNode || new Comment(` if: ${condition} `));\n\t}\n}\n\n", "import {Directive} from \"../directive\";\nimport {CWCO} from \"../cwco\";\n\nexport class Ref extends Directive {\n\tparseValue(value: string): string {\n\t\treturn `\"${value}\"`;\n\t}\n\n\trender(name: string, {element}: CWCO.directiveRenderOptions) {\n\t\tif (/^[a-z$_][a-z0-9$_]*$/i.test(name)) {\n\t\t\tthis.setRef(name, element);\n\t\t\treturn element;\n\t\t}\n\n\t\tthrow new Error(`Invalid \"ref\" property name \"${name}\"`)\n\t}\n}\n\n", "export function turnKebabToCamelCasing(name: string): string {\n\treturn name\n\t\t.split(/-+/)\n\t\t.map((part, i) => i === 0 && part.length > 1 ? part : part[0].toUpperCase() + part.slice(1))\n\t\t.join('') ?? name;\n}", "export function turnCamelToKebabCasing(name: string): string {\n\treturn name\n\t\t.match(/(?:[A-Z]+(?=[A-Z][a-z])|[A-Z]+|[a-zA-Z])[a-z]*/g)\n\t\t?.map(p => p.toLowerCase())\n\t\t.join('-') ?? name;\n}\n", "import {Directive} from \"../directive\";\nimport {turnKebabToCamelCasing} from \"../utils/turn-kebab-to-camel-casing\";\nimport {turnCamelToKebabCasing} from \"../utils/turn-camel-to-kebab-casing\";\nimport booleanAttr from \"../utils/boolean-attributes.json\";\nimport {CWCO} from \"../cwco\";\n\nexport class Attr extends Directive {\n\tparseValue(value: string, prop: string | null): string {\n\t\tlet [attrName, property = null] = (prop ?? '').split('.');\n\t\tconst commaIdx = value.lastIndexOf(',');\n\n\t\treturn `[\"${attrName}\", \"${property || ''}\", ${commaIdx >= 0 ? value.slice(commaIdx + 1).trim() : value}, \"${commaIdx >= 0 ? value.slice(0, commaIdx).trim() : ''}\"]`;\n\t}\n\n\trender([attrName, property, shouldAdd, val]: any, {element}: CWCO.directiveRenderOptions): HTMLElement {\n\t\tswitch (attrName) {\n\t\t\tcase 'style':\n\t\t\t\tif (property) {\n\t\t\t\t\tproperty = turnKebabToCamelCasing(property);\n\n\t\t\t\t\telement.style[property] = shouldAdd ? val : '';\n\t\t\t\t} else {\n\t\t\t\t\tval\n\t\t\t\t\t\t.match(/([a-z][a-z-]+)(?=:):([^;]+)/g)\n\t\t\t\t\t\t?.forEach((style: string) => {\n\t\t\t\t\t\t\tlet [name, styleValue] = style.split(':').map(s => s.trim());\n\n\t\t\t\t\t\t\tif (shouldAdd) {\n\t\t\t\t\t\t\t\telement.style.setProperty(name, styleValue);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\telement.setAttribute(\n\t\t\t\t\t\t\t\t\t'style',\n\t\t\t\t\t\t\t\t\telement.style.cssText.replace(new RegExp(`${name}\\\\s*:\\\\s*${styleValue};?`, 'g'), ''))\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 'class':\n\t\t\t\tif (property) {\n\t\t\t\t\tif (shouldAdd) {\n\t\t\t\t\t\telement.classList.add(property);\n\t\t\t\t\t} else {\n\t\t\t\t\t\telement.classList.remove(property);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst classes = val.split(/\\s+/g);\n\n\t\t\t\t\tif (shouldAdd) {\n\t\t\t\t\t\tclasses.forEach((cls: string) => element.classList.add(cls));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclasses.forEach((cls: string) => element.classList.remove(cls));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'data':\n\t\t\t\tif (property) {\n\t\t\t\t\tif (shouldAdd) {\n\t\t\t\t\t\telement.dataset[turnKebabToCamelCasing(property)] = val;\n\t\t\t\t\t} else {\n\t\t\t\t\t\telement.removeAttribute(`data-${turnCamelToKebabCasing(property)}`)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (attrName) {\n\t\t\t\t\tif (shouldAdd) {\n\t\t\t\t\t\telement.setAttribute(attrName,\n\t\t\t\t\t\t\tbooleanAttr.hasOwnProperty(attrName) ? '' : `${val || shouldAdd}`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\telement.removeAttribute(attrName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t\treturn element;\n\t}\n}\n", "import selfClosingTags from './self-closing-tags.json';\n\nexport function parse(markup: string) {\n\tconst tagCommentPattern = /<!--([^]*?)-->|<(\\/|!)?([a-z][\\w-.:]*)((?:\\s*[a-z][\\w-.:]*(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'))?)+\\s*|\\s*)(\\/?)>/ig;\n\tconst root = document.createDocumentFragment();\n\tconst stack: Array<DocumentFragment | HTMLElement> = [root];\n\tlet match: RegExpExecArray | null = null;\n\tlet lastIndex = 0;\n\n\twhile ((match = tagCommentPattern.exec(markup)) !== null) {\n\t\tlet [fullMatch, comment, closeOrBangSymbol, tagName, attributes, selfCloseSlash] = match;\n\n\t\ttagName = tagName?.toUpperCase();\n\n\t\tif (closeOrBangSymbol === '!') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst parentNode = stack[stack.length - 1] || null;\n\n\t\t// grab in between text\n\t\tif (lastIndex !== match.index) {\n\t\t\tconst textNode = document.createTextNode(markup.slice(lastIndex, match.index));\n\t\t\tparentNode.appendChild(textNode);\n\t\t}\n\n\t\tlastIndex = tagCommentPattern.lastIndex;\n\n\t\tif (comment) {\n\t\t\tconst commentNode = document.createComment(comment);\n\t\t\tparentNode.appendChild(commentNode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (selfCloseSlash || (selfClosingTags as {[key: string]: string})[tagName]) {\n\t\t\tconst node = document.createElement(tagName);\n\n\t\t\tsetAttributes(node, attributes)\n\n\t\t\tparentNode.appendChild(node);\n\t\t} else if (closeOrBangSymbol === '/') {\n\t\t\tstack.pop();\n\t\t} else if (!closeOrBangSymbol) {\n\t\t\tconst node = document.createElement(tagName);\n\n\t\t\tsetAttributes(node, attributes)\n\n\t\t\tparentNode.appendChild(node);\n\n\t\t\tstack.push(node)\n\t\t}\n\t}\n\n\t// grab ending text\n\tif (lastIndex < markup.length) {\n\t\tconst textNode = document.createTextNode(markup.slice(lastIndex));\n\t\troot.appendChild(textNode);\n\t}\n\n\treturn root;\n}\n\nfunction setAttributes(node: HTMLElement, attributes: string) {\n\tconst attrPattern = /([a-z][\\w-.:]*)(?:\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|(\\S+)))?/ig;\n\tlet match: RegExpExecArray | null = null;\n\n\twhile ((match = attrPattern.exec(attributes))) {\n\t\tlet name = match[1];\n\t\tconst value = match[2] || match[3] || match[4] || (\n\t\t\tnew RegExp(`^${match[1]}\\\\s*=`).test(match[0]) ? '' : null\n\t\t)\n\n\t\tnode.setAttribute(name, value ?? '');\n\t}\n}\n", "import {Directive} from \"../directive\";\nimport {parse} from \"../utils/parse\";\nimport {CWCO} from \"../cwco\";\n\nexport class Repeat extends Directive {\n\tparseValue(value: string): string {\n\t\tconst idx = value.lastIndexOf(';');\n\t\tlet iPart = value;\n\t\tlet kPart = '';\n\t\t\n\t\tif (idx > 0) {\n\t\t\tiPart = value.slice(0, idx);\n\t\t\tkPart = value.slice(idx + 1);\n\t\t}\n\t\t\n\t\tconst [v, vAs = \"$item\"] = `${iPart} `.split(/\\s+as\\s+/g).map(s => s.trim());\n\t\tconst [k, kAs = \"$key\"] = `${kPart} `.split(/\\s+as\\s+/g).map(s => s.trim());\n\t\t\n\t\treturn `[${v}, \"${vAs}\", \"${k === '$key' ? kAs : ''}\"]`;\n\t}\n\t\n\trender([repeatData, vAs, kAs]: any, {element, rawElementOuterHTML, anchorNode}: CWCO.directiveRenderOptions) {\n\t\tanchorNode = (anchorNode ?? []) as Array<Element>;\n\t\tconst list: Array<Element> = [];\n\n\t\tif (element.nodeType === 1) {\n\t\t\tlet times: number;\n\n\t\t\tif (Number.isInteger(repeatData)) {\n\t\t\t\ttimes = repeatData;\n\t\t\t} else {\n\t\t\t\trepeatData = repeatData instanceof Set ? Object.entries(Array.from(repeatData))\n\t\t\t\t\t: repeatData instanceof Map ? Array.from(repeatData.entries())\n\t\t\t\t\t\t: repeatData[Symbol.iterator] ? Object.entries([...repeatData])\n\t\t\t\t\t\t\t: Object.entries(repeatData);\n\t\t\t\ttimes = repeatData.length;\n\t\t\t}\n\n\t\t\tfor (let index = 0; index < times; index++) {\n\t\t\t\tif (anchorNode[index]) {\n\t\t\t\t\tthis.updateNodeContext(anchorNode[index], index, vAs, kAs, repeatData);\n\t\t\t\t\tlist.push(anchorNode[index]);\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tconst el = this.cloneRepeatedNode(rawElementOuterHTML);\n\t\t\t\tthis.updateNodeContext(el, index, vAs, kAs, repeatData)\n\t\t\t\tlist.push(el);\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t}\n\t\n\tupdateNodeContext(el: Node, index: number, vAs: string, kAs: string, list: Array<any> = []) {\n\t\tconst [key, value] = list[index] ?? [index, index + 1];\n\t\t// set context so this and inner nodes can catch these values\n\t\tthis.updateContext(el, {\n\t\t\t[vAs || '$item']: value,\n            [kAs || '$key']: key\n\t\t});\n\t}\n\n\tcloneRepeatedNode(rawElementOuterHTML: string): Element {\n\t\tconst clone = parse(rawElementOuterHTML).children[0];\n\t\t// remove the repeat node to avoid infinite loop where the clone node also repeat\n\t\tclone.removeAttribute('repeat');\n\t\t// remove the if because the if directive is execute before any directive\n\t\t// which means if the node reached the repeat, it was already processed by possibly\n\t\t// existing if directive\n\t\tclone.removeAttribute('if');\n\t\t\n\t\treturn clone;\n\t}\n}\n\n", "import {Directive} from \"../directive\";\nimport {CWCO} from \"../cwco\";\n\nexport class Bind extends Directive {\n\tparseValue(value: string, prop: string | null) {\n\t\treturn `[\"${(prop || '').trim()}\", \"${value}\"]`;\n\t}\n\n\trender([prop, value]: [string, any], {element, anchorNode}: CWCO.directiveRenderOptions) {\n\t\tif (prop) {\n\t\t\t(element as CWCO.ObjectLiteral)[prop] = value;\n\t\t} else {\n\t\t\telement.textContent = value;\n\t\t}\n\n\t\treturn element;\n\t}\n}\n\n", "import {If} from './if.directive';\nimport {Ref} from './ref.directive';\nimport {Attr} from './attr.directive';\nimport {Repeat} from './repeat.directive';\nimport {Bind} from \"./bind.directive\";\n\nIf.register();\nRef.register();\nAttr.register();\nRepeat.register();\nBind.register();\n\nexport const directives = new Set([\n\tIf.name.toLowerCase(),\n\tRef.name.toLowerCase(),\n\tAttr.name.toLowerCase(),\n\tRepeat.name.toLowerCase(),\n\tBind.name.toLowerCase(),\n])\n", "export function proxify(name: string, object: any, notify: (name: string, o: any) => void = () => {\n}, self = null): any {\n\tself = self ?? object;\n\n\tif (\n\t\t!object ||\n\t\tobject.__proxy__ ||\n\t\t/number|function|string|bigint|boolean/.test(typeof object) ||\n\t\t[String, Number, Boolean, BigInt].some(o => object instanceof o)\n\t) {\n\t\treturn object;\n\t}\n\n\treturn new Proxy(object, {\n\t\tget(obj, n: string) {\n\t\t\tlet res = Reflect.get(obj, n);\n\n\t\t\tif (res) {\n\t\t\t\tif (typeof res === 'object') {\n\t\t\t\t\treturn proxify(name, res, notify, self);\n\t\t\t\t}\n\n\t\t\t\tif (typeof res === 'function') {\n\t\t\t\t\tif (typeof n !== 'symbol') {\n\t\t\t\t\t\t// for each can be used to loop over the properties of an object\n\t\t\t\t\t\t// to change the value of each property which is the reason to proxify the items\n\t\t\t\t\t\t// but the same cannot be said to methods like map, reduce and filter\n\t\t\t\t\t\t// which return a new object and not the original one so for those\n\t\t\t\t\t\t// to have the change event triggered, the return objects must be used to replace the object\n\t\t\t\t\t\t// and get proxified in the process\n\t\t\t\t\t\tif (/forEach/.test(n)) {\n\t\t\t\t\t\t\treturn (cb: (v: any, k: number, l: any) => void, thisArg?: any) => {\n\t\t\t\t\t\t\t\tobj[n]((v: any, k: number, l: any) => {\n\t\t\t\t\t\t\t\t\tcb.call(thisArg ?? obj, proxify(name, v, notify, self), k, l);\n\t\t\t\t\t\t\t\t}, thisArg ?? obj);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else if (/values|entries|keys/.test(n)) {\n\t\t\t\t\t\t\t// keys need to also be proxified becuase they may be objects which are used in the\n\t\t\t\t\t\t\t// template for rendering\n\t\t\t\t\t\t\treturn () => ({\n\t\t\t\t\t\t\t\t*[Symbol.iterator]() {\n\t\t\t\t\t\t\t\t\tif (n === 'entries') {\n\t\t\t\t\t\t\t\t\t\tfor (const [k, v] of obj[n]()) {\n\t\t\t\t\t\t\t\t\t\t\tyield [proxify(name, k, notify, self), proxify(name, v, notify, self)];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tfor (const v of obj[n]()) {\n\t\t\t\t\t\t\t\t\t\t\tyield proxify(name, v, notify, self);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn (...args: any[]) => {\n\t\t\t\t\t\t\tconst r = res.apply(obj, args);\n\n\t\t\t\t\t\t\t// reading any item while it is still in the object should be proxified\n\t\t\t\t\t\t\t// to allow for detecting changes\n\t\t\t\t\t\t\tif (typeof r === 'object' && (\n\t\t\t\t\t\t\t\t(Array.isArray(obj) && /at|find/.test(n)) ||\n\t\t\t\t\t\t\t\t((obj instanceof Map) && /get/.test(n)) ||\n\t\t\t\t\t\t\t\t((obj instanceof WeakMap) && /get/.test(n))\n\t\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\t\treturn proxify(name, r, notify, self);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// this is done under the assumption that the function\n\t\t\t\t\t\t\t// will always update the object\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t(Array.isArray(obj) && /push|pop|splice|shift|unshift|reverse|sort|fill|copyWithin/.test(n)) ||\n\t\t\t\t\t\t\t\t((obj instanceof Map) && /set|delete|clear/.test(n)) ||\n\t\t\t\t\t\t\t\t((obj instanceof Set) && /add|delete|clear/.test(n)) ||\n\t\t\t\t\t\t\t\t((obj instanceof WeakSet) && /add|delete/.test(n)) ||\n\t\t\t\t\t\t\t\t((obj instanceof WeakMap) && /set|delete/.test(n))\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tnotify(name, self);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn r;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// make sure the object it bound to the function for when it is called\n\t\t\t\t\t\tres = res.bind(obj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn res;\n\t\t},\n\t\tset(obj, n: string, value) {\n\t\t\tconst res = Reflect.set(obj, n, value);\n\n\t\t\tnotify(name, self);\n\n\t\t\treturn res;\n\t\t},\n\t\tdeleteProperty(target: any, p: string | symbol): boolean {\n            const res = Reflect.deleteProperty(target, p);\n\n            notify(name, self);\n\n            return res;\n        },\n\t\tdefineProperty(target: any, p: string | symbol, attributes: PropertyDescriptor): boolean {\n            const res = Reflect.defineProperty(target, p, attributes);\n\n            notify(name, self);\n\n            return res;\n        },\n\t});\n}\n", "export function jsonParse(value: string): any {\n\tif (value && typeof value === 'string') {\n\t\ttry {\n\t\t\tvalue = JSON.parse(value.replace(/['`]/g, '\"'));\n\t\t} catch (e) {\n\t\t}\n\t}\n\n\treturn value;\n}", "import {proxify} from './proxify';\nimport boolAttr from './boolean-attributes.json';\nimport {directives} from \"../directives\";\nimport {jsonParse} from \"./json-parse\";\nimport {$} from \"../metadata\";\nimport {CWCO} from \"../cwco\";\n\nexport function setComponentPropertiesFromObservedAttributes(\n\tcomp: CWCO.WebComponent,\n\tattrs: string[],\n\tattrsMap: CWCO.ObjectLiteral = {},\n\tcb: CWCO.onUpdateCallback\n): string[] {\n\tconst properties: string[] = [];\n\n\tattrs.forEach(attr => {\n\t\tattr = attr.trim();\n\n\t\tif (!directives.has(attr) && !(attr.startsWith('data-') || attr === 'class' || attr === 'style')) {\n\t\t\tlet prop = attrsMap[attr];\n\t\t\tlet value: any = comp.getAttribute(attr) ?? comp[prop] ?? '';\n\n\t\t\tproperties.push(prop);\n\n\t\t\tvalue = proxify(prop, jsonParse(value), (name, val) => {\n\t\t\t\tcb(name, val, val);\n\t\t\t});\n\t\t\t\n\t\t\tif ((boolAttr).hasOwnProperty(prop)) {\n\t\t\t\tvalue = comp.hasAttribute(attr);\n\t\t\t\tprop = (boolAttr as CWCO.booleanAttributes)[prop].name;\n\t\t\t}\n\n\t\t\tif (value && typeof value === 'object') {\n\t\t\t\tcomp.removeAttribute(attr);\n\t\t\t}\n\n\t\t\tObject.defineProperty(comp, prop, {\n\t\t\t\tget() {\n\t\t\t\t\treturn value;\n\t\t\t\t},\n\t\t\t\tset(newValue) {\n\t\t\t\t\tif (comp.hasAttribute(attr) && typeof newValue === 'object') {\n\t\t\t\t\t\t$.get(comp).clearAttr = true;\n\t\t\t\t\t\tcomp.removeAttribute(attr);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (value !== newValue) {\n\t\t\t\t\t\tconst oldValue = value;\n\t\t\t\t\t\tvalue = proxify(prop, newValue, () => {\n\t\t\t\t\t\t\tcb(prop, oldValue, value);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tcb(prop, oldValue, newValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n\n\treturn properties;\n}\n", "import {turnCamelToKebabCasing} from \"./turn-camel-to-kebab-casing\";\nimport {directives} from \"../directives\";\nimport {proxify} from \"./proxify\";\nimport {CWCO} from \"../cwco\";\n\nexport function setupComponentPropertiesForAutoUpdate(component: CWCO.WebComponent, onUpdate: CWCO.onUpdateCallback): string[] {\n\tconst properties: string[] = [];\n\n\tfor (let property of Object.getOwnPropertyNames(component)) {\n\t\tconst attr = turnCamelToKebabCasing(property);\n\n\t\t// ignore private properties and $ properties as well as attribute properties\n\t\tif (!directives.has(property) && !/\\$|_/.test(property[0]) && !(component.constructor as CWCO.WebComponentConstructor).observedAttributes.includes(attr)) {\n\t\t\t// @ts-ignore\n\t\t\tlet value = component[property];\n\n\t\t\tproperties.push(property);\n\n\t\t\tvalue = proxify(property, value, () => {\n\t\t\t\tonUpdate(property, value, value);\n\t\t\t})\n\n\t\t\tObject.defineProperty(component, property, {\n\t\t\t\tget() {\n\t\t\t\t\treturn value;\n\t\t\t\t},\n\t\t\t\tset(newValue) {\n\t\t\t\t\tconst oldValue = value;\n\t\t\t\t\tvalue = proxify(property, newValue, () => {\n\t\t\t\t\t\tonUpdate(property, oldValue, value);\n\t\t\t\t\t});\n\n\t\t\t\t\tif (newValue !== oldValue) {\n\t\t\t\t\t\tonUpdate(property, oldValue, newValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\treturn properties;\n}\n", "export function getStyleString(stylesheet: string, tagName: string, hasShadowRoot: boolean = true) {\n\tstylesheet = stylesheet.trim().replace(/\\s{2,}/g, ' ');\n\n\tif (!stylesheet) {\n\t    return '';\n\t}\n\n\tconst div = document.createElement('div');\n\n\tdiv.innerHTML = stylesheet;\n\tconst styleTag = document.createElement('style');\n\n\tconst linkElements: HTMLLinkElement[] = []\n\n\tArray.from(div.childNodes).forEach(child => {\n\t\tif (child.nodeName === 'LINK' && ((child as HTMLLinkElement).getAttribute('rel') || '').trim() === 'stylesheet') {\n\t\t\tlinkElements.push(child as HTMLLinkElement);\n\t\t} else if (child.nodeName === 'STYLE') {\n\t\t\tstyleTag.appendChild(child.childNodes[0]);\n\t\t} else if(child.nodeName === '#text') {\n\t\t\tstyleTag.appendChild(child);\n\t\t}\n\t});\n\n\tif (!hasShadowRoot) {\n\t\tstyleTag.classList.add(tagName);\n\t\tstyleTag.textContent = (styleTag.innerHTML).replace(/(:host)((\\s*\\(.*\\)|))?/g, (_, h, s) => {\n\t\t\tif (s) {\n\t\t\t\treturn tagName + s.trim().slice(1, -1).trim();\n\t\t\t}\n\t\t\treturn tagName;\n\t\t})\n\t}\n\n\treturn (styleTag.innerHTML.trim() && styleTag.outerHTML) + linkElements.map(link => link.outerHTML).join('');\n}\n", "import {CWCO} from \"../cwco\";\n\nexport function extractExecutableSnippetFromString(str: string, [start, end] = ['{', '}']) {\n\tconst stack = [];\n\tconst pattern = new RegExp(`[\\\\${start}\\\\${end}]`, 'g');\n\tlet snippets: CWCO.Executable[] = [];\n\tlet match;\n\tlet startingCurlyIndex: number;\n\n\twhile ((match = pattern.exec(str)) !== null) {\n\t\tconst char = match[0];\n\n\t\tif (char === start) {\n\t\t\tstack.push(match.index);\n\t\t} else if (char === end && stack.length) {\n\t\t\tstartingCurlyIndex = stack.pop() as number;\n\n\t\t\tconst matchStr = str.slice(startingCurlyIndex + 1, match.index);\n\n\t\t\tif (matchStr) {\n\t\t\t\tfor (let j = 0; j < snippets.length; j++) {\n\t\t\t\t\tconst snippet = snippets[j];\n\n\t\t\t\t\tif (snippet.from > startingCurlyIndex && snippet.to < match.index) {\n\t\t\t\t\t\tsnippets.splice(j, 1)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsnippets.push({\n\t\t\t\t\tfrom: startingCurlyIndex,\n\t\t\t\t\tto: match.index,\n\t\t\t\t\tmatch: `${start}${matchStr}${end}`,\n\t\t\t\t\texecutable: matchStr\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn snippets;\n}\n", "import {CWCO} from \"../cwco\";\n\nexport function parseNodeDirective(node: Element, name: string, value: string): CWCO.DirectiveValue {\n\tconst dot = name.indexOf('.');\n\tlet prop = null;\n\n\tif (dot >= 0) {\n\t\tprop = name.slice(dot + 1);\n\t\tname = name.slice(0, dot);\n\t}\n\n\treturn {name, value, prop};\n}\n", "import {CWCO} from \"../cwco\";\n\nexport function evaluateStringInComponentContext(\n\texecutable: string,\n\tcomponent: CWCO.WebComponent,\n\tnodeData: CWCO.ObjectLiteral = {}\n) {\n\tif (!executable.trim()) {\n\t\treturn '';\n\t}\n\t\n\tconst ctx = component.$context;\n\tconst keys = Array.from(new Set([\n\t\t...Object.getOwnPropertyNames(nodeData),\n\t\t...Object.getOwnPropertyNames(ctx),\n\t\t...component.$properties\n\t]));\n\n\treturn (\n\t\tnew Function(...keys, `\"use strict\";\\n return ${executable};`)\n\t).apply(component, keys.map((key: string) => nodeData[key] ?? component[key] ?? ctx[key] ?? null)) ?? '';\n}\n", "import {evaluateStringInComponentContext} from \"./evaluate-string-in-component-context\";\nimport {CWCO} from \"../cwco\";\n\nexport function resolveExecutable(component: CWCO.WebComponent, nodeData: CWCO.ObjectLiteral, {match, executable}: CWCO.Executable, newValue: string) {\n\tlet res = evaluateStringInComponentContext(executable, component, nodeData);\n\n\tif (res && typeof res === 'object') {\n\t\ttry {\n\t\t\tres = JSON.stringify(res)\n\t\t} catch (e) {\n\t\t}\n\t}\n\n\treturn newValue.replace(match, res);\n}\n", "import {CWCO} from \"../cwco\";\n\nexport function getComponentNodeEventListener(\n\tcomponent: CWCO.WebComponent,\n\tname: string,\n\tvalue: string,\n\tprops: Array<string> = [],\n\tvalues: Array<unknown> = [],\n): CWCO.EventListenerCallback | null {\n\tvalue = value.trim()\n\tconst match = value.match(/^(?:((?:this\\.)?([a-z$_][a-z0-9$_]*)\\s*\\((.*)\\))|\\{(.*)\\})$/i);\n\n\tif (match) {\n\t\tlet [_, fn, fnName, fnArgs, executable] = match;\n\n\t\tif (executable) {\n\t\t\tconst fn = new Function('$event', ...props, `\"use strict\";\\n return ${executable};`);\n\n\t\t\treturn (event: Event) => fn.call(component, event, ...values);\n\t\t} else {\n\t\t\tfn = fn.replace(/^this\\./, '');\n\t\t\tconst func = new Function('$event', ...props, `\"use strict\";\\n return this.${fn}`);\n\n\t\t\t// @ts-ignore\n\t\t\tif (typeof component[fnName] === 'function') {\n\t\t\t\treturn (event: Event) => func.call(component, event, ...values);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n}\n", "import {getComponentNodeEventListener} from \"./get-component-node-event-listener\";\nimport {CWCO} from \"../cwco\";\n\nexport function getEventHandlerFunction(component: CWCO.WebComponent, nodeData: CWCO.ObjectLiteral, attribute: Attr): CWCO.EventListenerCallback | null {\n\tconst props = Array.from(new Set([...Object.getOwnPropertyNames(nodeData), ...component.$properties]));\n\tconst values = props.map(k => {\n\t\treturn nodeData[k] ?? component[k] ?? null;\n\t});\n\n\tconst fn = getComponentNodeEventListener(component, attribute.name, attribute.value, props, values);\n\n\tif (fn) {\n\t\treturn fn;\n\t} else {\n\t\tcomponent.onError(new Error(`${component.constructor.name}: Invalid event handler for \"${attribute.name}\" >>> \"${attribute.value}\".`))\n\t}\n\n\treturn null\n}\n", "import {extractExecutableSnippetFromString} from \"./utils/extract-executable-snippet-from-string\";\nimport {parseNodeDirective} from \"./utils/parse-node-directive\";\nimport {resolveExecutable} from \"./utils/resolve-executable\";\nimport {getEventHandlerFunction} from \"./utils/get-event-handler-function\";\nimport {directiveRegistry} from './directives/registry';\nimport {evaluateStringInComponentContext} from \"./utils/evaluate-string-in-component-context\";\nimport {$} from \"./metadata\";\nimport {trackNode} from \"./utils/track-node\";\nimport {CWCO} from \"./cwco\";\n\n/**\n * handles all logic related to tracking and updating a tracked node.\n * It is a extension of the component that handles all the logic related to updating nodes\n * in conjunction with the node component\n */\nexport class NodeTrack implements CWCO.NodeTrack {\n\tnode: HTMLElement | Node;\n\treadonly attributes: Array<{\n\t\tname: string;\n\t\tvalue: string;\n\t\texecutables: Array<CWCO.Executable>;\n\t}> = []\n\treadonly directives: Array<CWCO.DirectiveValue> = [];\n\tproperty: {\n\t\tname: string;\n\t\tvalue: string;\n\t\texecutables: Array<CWCO.Executable>;\n\t} = {\n\t\tname: '',\n\t\tvalue: '',\n\t\texecutables: []\n\t};\n\treadonly component: CWCO.WebComponent;\n\tanchor: HTMLElement | Node | Comment | Array<Element>;\n\tanchorDir: CWCO.DirectiveValue | null = null;\n\tempty = false;\n\treadonly tracks = new Map();\n\treadonly dirValues = new WeakMap();\n\treadonly dirAnchors = new WeakMap();\n\n\tconstructor(node: HTMLElement | Node, component: CWCO.WebComponent) {\n\t\tthis.node = node;\n\t\tthis.anchor = node;\n\t\tthis.component = component;\n\n\t\t$.get(this.node).rawNodeString = /#text|#comment/.test(node.nodeName)\n\t\t\t? node.nodeValue\n\t\t\t: (node as HTMLElement).outerHTML;\n\n\t\tthis._setTracks();\n\n\t}\n\n\tget $context() {\n\t\t// use this track node context if it does not happen to be anchored\n\t\t// otherwise the anchor context will reflect its ancestor's context\n\t\treturn (this.anchor === this.node\n\t\t\t? $.get(this.node).$context\n\t\t\t: $.get((this.anchor as Array<Element>)[0] ?? this.anchor)?.$context) || {};\n\t}\n\n\tupdateNode() {\n\t\tlet updated = false;\n\t\tlet directiveNode: any = this.node;\n\n\t\tfor (let directive of this.directives) {\n\t\t\tif (directive && directive.handler) {\n\t\t\t\ttry {\n\t\t\t\t\tconst {handler} = directive;\n\n\t\t\t\t\tlet val = handler.parseValue(directive.value, directive.prop);\n\t\t\t\t\textractExecutableSnippetFromString(val).forEach((exc) => {\n\t\t\t\t\t\tval = resolveExecutable(this.component, this.$context, exc, val);\n\t\t\t\t\t});\n\n\t\t\t\t\tconst value = evaluateStringInComponentContext(val, this.component, this.$context);\n\t\t\t\t\t\n\t\t\t\t\t// compare with previous directive value before rendering the directive\n\t\t\t\t\tif (this.dirValues.get(directive) !== value) {\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t\n\t\t\t\t\t\tdirectiveNode = handler.render(value, {\n\t\t\t\t\t\t\telement: this.node,\n\t\t\t\t\t\t\tanchorNode: this.dirAnchors.get(directive) ?? null,\n\t\t\t\t\t\t\trawElementOuterHTML: $.get(this.node).rawNodeString\n\t\t\t\t\t\t} as CWCO.directiveRenderOptions);\n\t\t\t\t\t\t\n\t\t\t\t\t\tthis.dirValues.set(directive, value);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (directiveNode !== this.node) {\n\t\t\t\t\t\t\tthis.dirAnchors.set(directive, directiveNode);\n\t\t\t\t\t\t\tthis.anchorDir = directive;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(this.anchorDir === directive) {\n\t\t\t\t\t\t// if this directive happens to be the one which cause this node to be anchored\n\t\t\t\t\t\t// and its value did not change, we can just quit the updating al together\n\t\t\t\t\t\t// since nothing else will update this node\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} catch (e: any) {\n\t\t\t\t\tthis.component.onError(new Error(`\"${directive.name}\" on ${$.get(this.node).rawNodeString}: ${e.message}`));\n\t\t\t\t}\n\n\t\t\t\tthis.dirAnchors.set(directive, null)\n\t\t\t}\n\t\t}\n\n\t\tif (directiveNode === this.node) {\n\t\t\tthis.anchorDir = null;\n\t\t\tthis.anchor = this._switchNodeAndAnchor(directiveNode);\n\n\t\t\tif (this.property?.executables.length) {\n\t\t\t\tconst newValue = this.property.executables.reduce((val, exc) => {\n\t\t\t\t\treturn resolveExecutable(this.component, this.$context, exc, val);\n\t\t\t\t}, this.property.value)\n\n\t\t\t\tif (newValue !== (this.node as CWCO.ObjectLiteral)[this.property.name]) {\n\t\t\t\t\tupdated = true;\n\t\t\t\t\t(this.node as CWCO.ObjectLiteral)[this.property.name] = newValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let {name, value, executables} of this.attributes) {\n\t\t\t\tif (executables.length) {\n\t\t\t\t\tlet newValue = executables.reduce((val, exc) => {\n\t\t\t\t\t\treturn resolveExecutable(this.component, this.$context, exc, val);\n\t\t\t\t\t}, value);\n\n\t\t\t\t\tif ((this.node as HTMLElement).getAttribute(name) !== newValue) {\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t(this.node as HTMLElement).setAttribute(name, newValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.tracks.forEach((track) => {\n\t\t\t\ttrack.updateNode();\n\t\t\t});\n\n\t\t} else {\n\t\t\tthis.anchor = this._switchNodeAndAnchor(directiveNode);\n\t\t}\n\n\t\treturn updated;\n\t}\n\n\tprivate _setTracks() {\n\t\tconst dirPattern = new RegExp(`^(${Object.keys(directiveRegistry).join('|')})\\\\.?`);\n\t\tconst {nodeName, nodeValue, textContent, attributes} = this.node as HTMLElement;\n\t\tconst eventHandlers: Array<CWCO.EventHandlerTrack> = [];\n\n\t\tif (nodeName === '#text') {\n\t\t\tthis.property = {\n\t\t\t\tname: 'nodeValue',\n\t\t\t\tvalue: nodeValue || '',\n\t\t\t\texecutables: []\n\t\t\t}\n\t\t} else {\n\t\t\tconst attrs = [];\n\t\t\tconst isRepeatedNode = (this.node as HTMLElement)?.hasAttribute('repeat');\n\n\t\t\tif (nodeName === 'TEXTAREA') {\n\t\t\t\tthis.property = {\n\t\t\t\t\tname: 'textContent',\n\t\t\t\t\tvalue: textContent || '',\n\t\t\t\t\texecutables: []\n\t\t\t\t}\n\t\t\t} else if (nodeName === 'STYLE') {\n\t\t\t\tconst selectorPattern = /[a-z:#\\.*\\[][^{}]*[^\\s:]\\s*(?={){/gmi;\n\t\t\t\tconst propValueStylePattern = /[a-z][a-z-]*:([^;]*)(;|})/gmi;\n\t\t\t\tlet styleText = (textContent ?? '');\n\t\t\t\tlet match: RegExpExecArray | null = null;\n\t\t\t\tlet executables: Array<CWCO.Executable> = [];\n\n\t\t\t\twhile ((match = selectorPattern.exec(styleText)) !== null) {\n\t\t\t\t\tlet propValueMatch: RegExpExecArray | null = null;\n\t\t\t\t\tlet propValue = styleText.slice(selectorPattern.lastIndex);\n\n\t\t\t\t\twhile ((propValueMatch = propValueStylePattern.exec(propValue)) !== null) {\n\t\t\t\t\t\texecutables.push(...extractExecutableSnippetFromString(propValueMatch[1], ['[', ']']))\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (executables.length) {\n\t\t\t\t\tthis.property = {\n\t\t\t\t\t\tname: 'textContent',\n\t\t\t\t\t\tvalue: styleText,\n\t\t\t\t\t\texecutables\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// @ts-ignore\n\t\t\tfor (let attr of [...attributes]) {\n\t\t\t\tif (dirPattern.test(attr.name)) {\n\t\t\t\t\tconst directive = parseNodeDirective(this.node as HTMLElement, attr.name, attr.value);\n\n\t\t\t\t\tif (directiveRegistry[directive.name]) {\n\t\t\t\t\t\tconst Dir = directiveRegistry[directive.name];\n\t\t\t\t\t\tdirective.handler = new Dir(this.component);\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch (directive.name) {\n\t\t\t\t\t\tcase 'if':\n\t\t\t\t\t\t\tthis.directives.unshift(directive);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'repeat':\n\t\t\t\t\t\t\tif (this.directives[0]?.name === 'if') {\n\t\t\t\t\t\t\t\tthis.directives.splice(1, 0, directive);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.directives.unshift(directive);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthis.directives.push(directive);\n\t\t\t\t\t}\n\n\t\t\t\t\t(this.node as Element).removeAttribute(attr.name);\n\t\t\t\t} else if (attr.name.startsWith('on')) {\n\t\t\t\t\teventHandlers.push({\n\t\t\t\t\t\teventName: attr.name.slice(2).toLowerCase(),\n\t\t\t\t\t\tattribute: attr\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tattrs.push(attr)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\teventHandlers.forEach(({eventName, fn, attribute}) => {\n\t\t\t\t(this.node as HTMLElement).removeAttribute(attribute.name);\n\n\t\t\t\tif (!fn && !isRepeatedNode) {\n\t\t\t\t\tfn = getEventHandlerFunction(this.component, this.$context, attribute) as CWCO.EventListenerCallback;\n\n\t\t\t\t\tif (fn) {\n\t\t\t\t\t\tthis.node.addEventListener(eventName, fn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfor (let attr of attrs) {\n\t\t\t\tif (attr.value.trim()) {\n\t\t\t\t\tthis.attributes.push({\n\t\t\t\t\t\tname: attr.name,\n\t\t\t\t\t\tvalue: attr.value,\n\t\t\t\t\t\texecutables: extractExecutableSnippetFromString(attr.value)\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.property?.value.trim() && !this.property.executables.length) {\n\t\t\tthis.property.executables = extractExecutableSnippetFromString(this.property.value)\n\t\t}\n\n\t\tthis.empty = !this.directives.length &&\n\t\t\t!this.attributes.some(attr => attr.executables.length) &&\n\t\t\t!this.property.executables.length;\n\t}\n\n\tprivate _createDefaultAnchor() {\n\t\treturn document.createComment(` ${this.node.nodeValue ?? (this.node as HTMLElement).outerHTML} `)\n\t}\n\n\tprivate _switchNodeAndAnchor(dirNode: HTMLElement | Node | Comment | Array<Element>) {\n\t\tif (dirNode === this.anchor) {\n\t\t\treturn dirNode;\n\t\t}\n\n\t\tlet dirIsArray = Array.isArray(dirNode);\n\n\t\tif (\n\t\t\t(dirIsArray && !(dirNode as Array<Element>).length) ||\n\t\t\t(!dirIsArray && !(/[831]/.test(`${(dirNode as Node).nodeType}`)))\n\t\t) {\n\t\t\tdirNode = this._createDefaultAnchor();\n\t\t\tdirIsArray = false;\n\t\t}\n\n\t\tconst anchorIsArray = Array.isArray(this.anchor);\n\t\tconst anchorEl = document.createComment('bfs')\n\t\tlet nextEl: Element | Comment | Text = anchorEl;\n\n\t\tif (anchorIsArray) {\n\t\t\t(this.anchor as Array<Element>)[0]?.parentNode?.insertBefore(nextEl, (this.anchor as Array<Element>)[0]);\n\t\t} else {\n\t\t\t(this.anchor as HTMLElement).before(nextEl);\n\t\t}\n\n\t\tif (dirIsArray) {\n\t\t\tfor (let el of (dirNode as Array<Element>)) {\n\t\t\t\tif (!el.isConnected) {\n\t\t\t\t\tnextEl.after(el);\n\t\t\t\t\tthis._trackNode(el);\n\t\t\t\t\t$.get(el).shadowNode = this.node;\n\t\t\t\t}\n\n\t\t\t\tnextEl = el;\n\t\t\t}\n\t\t} else {\n\t\t\tnextEl.after(dirNode as Node);\n\n\t\t\tif (!$.has(dirNode)) {\n\t\t\t\tthis._trackNode(dirNode as Node);\n\t\t\t}\n\t\t}\n\n\t\tif (anchorIsArray) {\n\t\t\tfor (let el of (this.anchor as Array<Element>)) {\n\t\t\t\tif (!dirIsArray || !(dirNode as Array<Element>).includes(el)) {\n\t\t\t\t\tel.parentNode?.removeChild(el);\n\t\t\t\t\tthis._unTrackNode(el);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.anchor !== dirNode) {\n\t\t\t(this.anchor as Node).parentNode?.removeChild(this.anchor as Node);\n\t\t\tthis._unTrackNode(this.anchor as Node);\n\t\t}\n\n\t\tanchorEl.parentNode?.removeChild(anchorEl);\n\n\t\tthis.anchor = dirNode;\n\n\t\treturn dirNode;\n\t}\n\n\tprivate _trackNode(n: Node) {\n\t\ttrackNode(n, this.component, {\n\t\t\ttracks: this.tracks\n\t\t})\n\t}\n\n\tprivate _unTrackNode(n: Node) {\n\t\tif (n !== this.node) {\n\t\t\tthis.tracks.delete(n);\n\t\t\tn.childNodes.forEach(c => this._unTrackNode(c));\n\t\t}\n\t}\n\n}\n", "import {CWCO} from \"../cwco\";\n\nexport const slotTag = (node: HTMLElement, {component}: CWCO.ObjectLiteral = {}, cb: (n: Node[]) => void): void => {\n\tif (component.type === 'context') {\n\t\tcb(renderCustomSlot(node, component.childNodes));\n\t} else {\n\t\trenderSlot(node, cb);\n\t}\n}\n\nfunction renderSlot(node: HTMLElement, cb: (c: Node[]) => void) {\n\tconst onSlotChange = () => {\n\t\tconst nodes = (node as HTMLSlotElement).assignedNodes();\n\t\t\n\t\tcb(nodes);\n\t\t\n\t\tnode.removeEventListener('slotchange', onSlotChange, false);\n\t};\n\t\n\tnode.addEventListener('slotchange', onSlotChange, false);\n\t\n\tcb(Array.from(node.childNodes));\n}\n\nfunction renderCustomSlot(node: HTMLElement, childNodes: Array<Node>) {\n\tconst name = node.getAttribute('name');\n\tlet nodeList: Node[];\n\tlet comment = document.createComment(`slotted [${name || ''}]`);\n\tnode.parentNode?.replaceChild(comment, node);\n\t\n\tif (name) {\n\t\tnodeList = childNodes.filter(n => {\n\t\t\treturn n.nodeType === 1 && (n as HTMLElement).getAttribute('slot') === name;\n\t\t});\n\t} else {\n\t\tnodeList = childNodes.filter(n => {\n\t\t\treturn n.nodeType !== 1 || !(n as HTMLElement).hasAttribute('slot');\n\t\t});\n\t}\n\t\n\tif (!nodeList.length) {\n\t\tnodeList = Array.from(node.childNodes);\n\t}\n\t\n\tlet anchor: Node = comment;\n\t\n\tfor (let n of nodeList) {\n\t\t(anchor as Element).after(n);\n\t\tanchor = n;\n\t}\n\t\n\tcomment.parentNode?.removeChild(comment);\n\t\n\treturn nodeList;\n}\n", "import {$} from \"../metadata\";\nimport {NodeTrack} from \"../node-track\";\nimport {defineNodeContextMetadata} from \"./define-node-context-metadata\";\nimport {slotTag} from \"../tags/slot.tag\";\nimport {CWCO} from \"../cwco\";\n\nexport function trackNode(node: Node | HTMLElement | DocumentFragment, component: CWCO.WebComponent, opt: CWCO.trackerOptions) {\n\tconst {nodeName, nodeValue, childNodes, nodeType} = node;\n\n\tif ($.get(node)?.tracked || (nodeName === '#text' && !nodeValue?.trim())) {\n\t\treturn;\n\t}\n\n\tdefineNodeContextMetadata(node);\n\t$.get(node).tracked = true;\n\n\tif (/#comment|SCRIPT/.test(nodeName)) {\n\t\treturn;\n\t}\n\n\tlet {trackOnly = false, tracks} = opt\n\t\n\tif (nodeName === 'SLOT') {\n\t\tslotTag(node as HTMLElement, {\n\t\t\tcomponent: {\n\t\t\t\ttype: component.customSlot ? 'context' : 'default',\n\t\t\t\tchildNodes: component._childNodes\n\t\t\t}\n\t\t}, (nodes: Node[]) => {\n\t\t\tnodes.forEach(node => {\n\t\t\t\ttrackNode(node, component, opt);\n\t\t\t})\n\t\t})\n\t} else {\n\t\t// avoid fragments\n\t\tif (nodeType !== 11) {\n\t\t\tif (nodeType === 1 || nodeName === '#text') {\n\t\t\t\tconst track: NodeTrack = new NodeTrack(node, component);\n\t\t\t\tif (!track.empty) {\n\t\t\t\t\t$.get(node).track = track;\n\t\t\t\t\ttracks.set(node, track);\n\n\t\t\t\t\tif (!trackOnly) {\n\t\t\t\t\t\ttrack.updateNode();\n\t\t\t\t\t\tif (track.anchor !== node) {\n\t\t\t\t\t\t\ttrackOnly = true;\n\n\t\t\t\t\t\t\tif (Array.isArray(track.anchor)) {\n\t\t\t\t\t\t\t   return;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks = track.tracks;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (/#text|TEXTAREA|STYLE/.test(nodeName)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tArray.from(childNodes).forEach(c => trackNode(c, component, {...opt, trackOnly, tracks}));\n\t}\n}\n", "export function resolveHtmlEntities(html: string): string {\n\tconst e = document.createElement('textarea');\n\te.innerHTML = html;\n\treturn e.textContent || '';\n}", "// simply importing directive here will automatically register them and make them available for\n// anything later on\nimport './directives';\nimport booleanAttr from './utils/boolean-attributes.json';\nimport {$} from \"./metadata\";\nimport {parse} from './utils/parse';\nimport {setComponentPropertiesFromObservedAttributes} from './utils/set-component-properties-from-observed-attributes';\nimport {setupComponentPropertiesForAutoUpdate} from './utils/setup-component-properties-for-auto-update';\nimport {turnCamelToKebabCasing} from './utils/turn-camel-to-kebab-casing';\nimport {turnKebabToCamelCasing} from './utils/turn-kebab-to-camel-casing';\nimport {getStyleString} from './utils/get-style-string';\nimport {ShadowRootModeExtended} from \"./enums/ShadowRootModeExtended.enum\";\nimport {trackNode} from \"./utils/track-node\";\nimport {jsonParse} from \"./utils/json-parse\";\nimport {defineNodeContextMetadata} from \"./utils/define-node-context-metadata\";\nimport {resolveHtmlEntities} from \"./utils/resolve-html-entities\";\nimport {CWCO} from \"./cwco\";\n\n/**\n * a extension on the native web component API to simplify and automate most of the pain points\n * when it comes to creating and working with web components on the browser\n */\nexport class WebComponent extends HTMLElement implements CWCO.WebComponent {\n\treadonly $refs: CWCO.Refs = {};\n\t$properties: Array<string> = ['$context', '$refs'];\n\t/**\n\t * the id of the template tag placed in the body of the document which contains the template content\n\t */\n\ttemplateId: string = '';\n\t_childNodes: Array<Node> = [];\n\t\n\tconstructor() {\n\t\tsuper();\n\n\t\tlet {mode, observedAttributes, delegatesFocus} = this.constructor as CWCO.WebComponentConstructor;\n\n\t\tif (!$.has(this)) {\n\t\t\t$.set(this, {})\n\t\t}\n\n\t\tconst meta = $.get(this);\n\n\t\tmeta.root = this;\n\t\tmeta.mounted = false;\n\t\tmeta.parsed = false;\n\t\tmeta.clearAttr = false;\n\t\tmeta.tracks = new Map();\n\t\tmeta.unsubscribeCtx = () => {};\n\t\tmeta.attrPropsMap = observedAttributes.reduce((map, attr) => ({\n\t\t\t...map,\n\t\t\t[attr]: turnKebabToCamelCasing(attr)\n\t\t}), {} as CWCO.ObjectLiteral);\n\n\t\tif (mode !== 'none') {\n\t\t\t$.get(this).root = this.attachShadow({mode, delegatesFocus});\n\t\t}\n\t}\n\t\n\t/**\n\t * an array of attribute names as they will look in the html tag\n\t * https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elementsusing_the_lifecycle_callbacks\n\t * @type {[]}\n\t */\n\tstatic observedAttributes: Array<string> = [];\n\t\n\t/**\n\t * shadow root mode\n\t * https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot/mode\n\t * plus an additional option of \"none\" to signal you dont want\n\t * the content to be places inside the shadow root but directly under the tag\n\t * @type {string}\n\t */\n\tstatic mode = ShadowRootModeExtended.OPEN;\n\t\n\t/**\n\t * shadow root delegate focus option\n\t * https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot/delegatesFocus\n\t * @type {boolean}\n\t */\n\tstatic delegatesFocus = false;\n\t\n\t/**\n\t * a valid name of the html tag\n\t * @type {string}\n\t */\n\tstatic tagName = '';\n\t\n\t/**\n\t * the initial context data for the component\n\t */\n\tstatic initialContext = {};\n\t\n\t/**\n\t * parses special template HTML string taking in consideration\n\t * all the additional syntax specific to this framework\n\t */\n\tstatic parseHTML(markup: string): DocumentFragment {\n\t\treturn parse(markup)\n\t}\n\t\n\t/**\n\t * registers the component with the CustomElementRegistry taking an optional tag name if not\n\t * specified as static member of the class as tagName\n\t * @param tagName\n\t */\n\tstatic register(tagName?: string | undefined) {\n\t\ttagName = typeof tagName === 'string' && tagName\n\t\t\t? tagName\n\t\t\t: typeof this.tagName === 'string' && this.tagName\n\t\t\t\t? this.tagName\n\t\t\t\t: turnCamelToKebabCasing(this.name);\n\t\t\n\t\tthis.tagName = tagName;\n\t\t\n\t\tif (!customElements.get(tagName)) {\n\t\t\tcustomElements.define(tagName, this);\n\t\t}\n\t}\n\t\n\t/**\n\t * registers a list of provided web component classes\n\t * @param components\n\t */\n\tstatic registerAll(components: Array<CWCO.WebComponentConstructor>) {\n\t\tcomponents.forEach(comp => comp.register());\n\t}\n\t\n\t/**\n\t * returns whether the component is registered or not\n\t */\n\tstatic get isRegistered() {\n\t\treturn customElements.get(this.tagName) !== undefined;\n\t}\n\t\n\t/**\n\t * template for the element HTML content\n\t */\n\tget template(): string {\n\t\treturn '';\n\t};\n\t\n\t/**\n\t * style for the component whether inside the style tag, as object or straight CSS string\n\t */\n\tget stylesheet(): string {\n\t\treturn '';\n\t};\n\t\n\t/**\n\t * whether or not the component should use the real slot element or mimic its behavior\n\t * when rendering template\n\t */\n\tget customSlot() {\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * the root element. If shadow root present it will be the shadow root otherwise\n\t * the actual element\n\t * @returns {*}\n\t */\n\tget root(): HTMLElement | ShadowRoot | null {\n\t\treturn (this.constructor as CWCO.WebComponentConstructor).mode === 'closed' ? null : $.get(this).root;\n\t}\n\t\n\t/**\n\t * whether or not the element is attached to the DOM and works differently than Element.isConnected\n\t * @returns {boolean}\n\t */\n\tget mounted() {\n\t\treturn $.get(this)?.mounted ?? false;\n\t}\n\t\n\tget parsed() {\n\t\treturn $.get(this).parsed;\n\t}\n\t\n\tget $context(): CWCO.ObjectLiteral {\n\t\treturn $.get(this).$context;\n\t}\n\t\n\tupdateContext(ctx: CWCO.ObjectLiteral) {\n\t\t$.get(this).updateContext(ctx);\n\t}\n\t\n\tconnectedCallback() {\n\t\tdefineNodeContextMetadata(this);\n\t\tconst {initialContext, observedAttributes, name} = this.constructor as CWCO.WebComponentConstructor;\n\t\tconst {parsed, tracks, root, attrPropsMap} = $.get(this);\n\n\t\tif (Object.keys(initialContext).length) {\n\t\t\t$.get(this).updateContext(initialContext);\n\t\t}\n\n\t\tconst onPropUpdate = (prop: string, oldValue: any, newValue: any, update = true) => {\n\t\t\tif (this.mounted) {\n\t\t\t\tif (update) {\n\t\t\t\t\tthis.forceUpdate();\n\t\t\t\t}\n\t\t\t\tthis.onUpdate(prop, oldValue, newValue);\n\t\t\t} else if(this.parsed) {\n\t\t\t\tthis.onError(new Error(`[Possibly a memory leak]: Cannot set property \"${prop}\" on unmounted component.`));\n\t\t\t}\n\t\t};\n\n\t\ttry {\n\t\t\t$.get(this).unsubscribeCtx = $.get(this).subscribe((newContext: CWCO.ObjectLiteral) => {\n\t\t\t\tonPropUpdate('$context', newContext, newContext, false);\n\t\t\t})\n\n\t\t\t$.get(this).mounted = true;\n\n\t\t\t/*\n\t\t\tonly need to parse the element the very first time it gets mounted\n\n\t\t\tthis will make sure that if the element is removed from the dom and mounted again\n\t\t\tall that needs to be done if update the DOM to grab the possible new context and updated data\n\t\t\t */\n\t\t\tif (parsed) {\n\t\t\t\tthis.updateContext({});\n\t\t\t} else {\n\n\t\t\t\tthis.$properties.push(\n\t\t\t\t\t...setComponentPropertiesFromObservedAttributes(this, observedAttributes, attrPropsMap, onPropUpdate),\n\t\t\t\t\t...setupComponentPropertiesForAutoUpdate(this, onPropUpdate)\n\t\t\t\t)\n\t\t\t\t\n\t\t\t\tObject.freeze(this.$properties);\n\t\t\t\t\n\t\t\t\tlet contentNode;\n\t\t\t\tconst hasShadowRoot = (this.constructor as CWCO.WebComponentConstructor).mode !== 'none';\n\t\t\t\tconst style = getStyleString(this.stylesheet, (this.constructor as CWCO.WebComponentConstructor).tagName, hasShadowRoot);\n\t\t\t\tlet temp: string = this.template;\n\t\t\t\t\n\t\t\t\tif (!temp && this.templateId) {\n\t\t\t\t\tconst t = document.getElementById(this.templateId);\n\t\t\t\t\t\n\t\t\t\t\ttemp = t?.nodeName === 'TEMPLATE' ? t.innerHTML : temp;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcontentNode = parse(resolveHtmlEntities(style + temp));\n\n\t\t\t\tthis._childNodes = Array.from(this.childNodes);\n\t\t\t\t\n\t\t\t\tif (this.customSlot) {\n\t\t\t\t\tthis.innerHTML = '';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttrackNode(contentNode, this, {\n\t\t\t\t\ttracks,\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tconst {tagName, mode} = (this.constructor as CWCO.WebComponentConstructor);\n\t\t\t\t\n\t\t\t\tif (mode === 'none') {\n\t\t\t\t\t[\n\t\t\t\t\t\t...Array.from(contentNode.querySelectorAll('style')),\n\t\t\t\t\t\t...Array.from(contentNode.querySelectorAll('link')),\n\t\t\t\t\t].forEach((el: HTMLElement) => {\n\t\t\t\t\t\tconst existingEl: HTMLStyleElement | null = document.head.querySelector(`${el.nodeName.toLowerCase()}.${tagName}`);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (existingEl) {\n\t\t\t\t\t\t\texistingEl.textContent = el.textContent;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdocument.head.appendChild(el);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$.get(this).parsed = true;\n\t\t\t\troot.appendChild(contentNode);\n\t\t\t}\n\n\n\t\t\tthis.onMount();\n\t\t} catch (e) {\n\t\t\tthis.onError(e as ErrorEvent);\n\t\t}\n\t}\n\t\n\t/**\n\t * livecycle callback for when the element is attached to the DOM\n\t */\n\tonMount() {\n\t}\n\t\n\tdisconnectedCallback() {\n\t\ttry {\n\t\t\t$.get(this).mounted = false;\n\t\t\t$.get(this).unsubscribeCtx();\n\t\t\tthis.onDestroy();\n\t\t} catch (e) {\n\t\t\tthis.onError(e as Error)\n\t\t}\n\t}\n\t\n\t/**\n\t * livecycle callback for when the element is removed from the DOM\n\t */\n\tonDestroy() {\n\t}\n\t\n\tattributeChangedCallback(name: string, oldValue: any, newValue: any) {\n\t\tif (newValue === null && !this.hasAttribute(name) && $.get(this).clearAttr) {\n\t\t\t$.get(this).clearAttr = false;\n\t\t} else if (this.mounted) {\n\t\t\ttry {\n\t\t\t\tif (!(name.startsWith('data-') || name === 'class' || name === 'style')) {\n\t\t\t\t\tconst prop: any = $.get(this).attrPropsMap[name];\n\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tthis[prop] = booleanAttr.hasOwnProperty(prop)\n\t\t\t\t\t\t? this.hasAttribute(name)\n\t\t\t\t\t\t: jsonParse(newValue);\n\t\t\t\t} else {\n\t\t\t\t\tthis.forceUpdate();\n\t\t\t\t\tthis.onUpdate(name, oldValue, newValue);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tthis.onError(e as ErrorEvent)\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * livecycle callback for when the element attributes or class properties are updated\n\t */\n\tonUpdate(name: string, oldValue: unknown, newValue: unknown) {\n\t}\n\t\n\t/**\n\t * updates any already tracked node with current component data including context and node level data.\n\t */\n\tforceUpdate() {\n\t\tif (this.mounted) {\n\t\t\tcancelAnimationFrame($.get(this).updateFrame);\n\t\t\t$.get(this).updateFrame = requestAnimationFrame(() => {\n\t\t\t\t$.get(this).tracks.forEach((t: CWCO.NodeTrack) => {\n\t\t\t\t\tt.updateNode();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\t\n\tadoptedCallback() {\n\t\ttry {\n\t\t\tthis.onAdoption();\n\t\t} catch (e) {\n\t\t\tthis.onError(e as Error)\n\t\t}\n\t}\n\t\n\t/**\n\t * livecycle callback for when element is moved into a new document\n\t */\n\tonAdoption() {\n\t}\n\t\n\t/**\n\t * error callback for when an error occurs\n\t */\n\tonError(error: ErrorEvent | Error) {\n\t\tconsole.error(this.constructor.name, error);\n\t}\n}\n\n", "import {ShadowRootModeExtended} from \"./enums/ShadowRootModeExtended.enum\";\nimport {WebComponent} from \"./web-component\";\nimport {CWCO} from \"./cwco\";\n\n/**\n * a special WebComponent that handles slot tag differently allowing for render template right into HTML files\n */\nexport class ContextProviderComponent extends WebComponent implements CWCO.WebComponent  {\n\tget customSlot() {\n\t\treturn true;\n\t}\n\n\tstatic mode = ShadowRootModeExtended.NONE;\n\t\n\tget template() {\n\t\treturn '<slot></slot>';\n\t}\n\n\tget stylesheet() {\n\t\treturn ':host { display: block; }';\n\t}\n}\n", "// cwco, copyright (c) by Elson Correia\n// Distributed under an MIT license: https://github.com/beforesemicolon/cwco/blob/master/LICENSE\n\nimport {WebComponent} from './web-component';\nimport {Directive} from './directive';\nimport {ContextProviderComponent} from './context-provider-component';\n\n// @ts-ignore\nif (window) {\n\t// @ts-ignore\n\twindow.WebComponent = WebComponent;\n\t// @ts-ignore\n\twindow.ContextProviderComponent = ContextProviderComponent;\n\t// @ts-ignore\n\twindow.Directive = Directive;\n}\n"],
  "mappings": "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",
  "names": []
}
